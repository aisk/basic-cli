// ⚠️ GENERATED CODE ⚠️ - this entire file was generated by the `roc glue` CLI command

#![allow(unused_unsafe)]
#![allow(dead_code)]
#![allow(unused_mut)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(clippy::undocumented_unsafe_blocks)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::unused_unit)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::let_and_return)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::needless_borrow)]
#![allow(clippy::clone_on_copy)]


#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_CommandErr {
    ExitCode = 0,
    IOError = 1,
    KilledBySignal = 2,
}

impl core::fmt::Debug for discriminant_CommandErr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::ExitCode => f.write_str("discriminant_CommandErr::ExitCode"),
            Self::IOError => f.write_str("discriminant_CommandErr::IOError"),
            Self::KilledBySignal => f.write_str("discriminant_CommandErr::KilledBySignal"),
        }
    }
}

#[repr(C, align(4))]
pub union union_CommandErr {
    ExitCode: i32,
    IOError: core::mem::ManuallyDrop<roc_std::RocStr>,
    KilledBySignal: (),
}

const _SIZE_CHECK_union_CommandErr: () = assert!(core::mem::size_of::<union_CommandErr>() == 12);
const _ALIGN_CHECK_union_CommandErr: () = assert!(core::mem::align_of::<union_CommandErr>() == 4);

const _SIZE_CHECK_CommandErr: () = assert!(core::mem::size_of::<CommandErr>() == 16);
const _ALIGN_CHECK_CommandErr: () = assert!(core::mem::align_of::<CommandErr>() == 4);

impl CommandErr {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_CommandErr {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_CommandErr>(*bytes.as_ptr().add(12))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_CommandErr) {
        let discriminant_ptr: *mut discriminant_CommandErr = (self as *mut CommandErr).cast();

        unsafe {
            *(discriminant_ptr.add(12)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct CommandErr {
    payload: union_CommandErr,
    discriminant: discriminant_CommandErr,
}

impl Clone for CommandErr {
    fn clone(&self) -> Self {
        use discriminant_CommandErr::*;

        let payload = unsafe {
            match self.discriminant {
                ExitCode => union_CommandErr {
                    ExitCode: self.payload.ExitCode.clone(),
                },
                IOError => union_CommandErr {
                    IOError: self.payload.IOError.clone(),
                },
                KilledBySignal => union_CommandErr {
                    KilledBySignal: self.payload.KilledBySignal.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for CommandErr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_CommandErr::*;

        unsafe {
            match self.discriminant {
                ExitCode => {
                    let field: &i32 = &self.payload.ExitCode;
                    f.debug_tuple("CommandErr::ExitCode").field(field).finish()
                },
                IOError => {
                    let field: &roc_std::RocStr = &self.payload.IOError;
                    f.debug_tuple("CommandErr::IOError").field(field).finish()
                },
                KilledBySignal => {
                    let field: &() = &self.payload.KilledBySignal;
                    f.debug_tuple("CommandErr::KilledBySignal").field(field).finish()
                },
            }
        }
    }
}

impl Eq for CommandErr {}

impl PartialEq for CommandErr {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_CommandErr::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                ExitCode => self.payload.ExitCode == other.payload.ExitCode,
                IOError => self.payload.IOError == other.payload.IOError,
                KilledBySignal => self.payload.KilledBySignal == other.payload.KilledBySignal,
            }
        }
    }
}

impl Ord for CommandErr {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for CommandErr {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_CommandErr::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    ExitCode => self.payload.ExitCode.partial_cmp(&other.payload.ExitCode),
                    IOError => self.payload.IOError.partial_cmp(&other.payload.IOError),
                    KilledBySignal => self.payload.KilledBySignal.partial_cmp(&other.payload.KilledBySignal),
                }
            },
        }
    }
}

impl core::hash::Hash for CommandErr {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_CommandErr::*;

        unsafe {
            match self.discriminant {
                ExitCode => self.payload.ExitCode.hash(state),
                IOError => self.payload.IOError.hash(state),
                KilledBySignal => self.payload.KilledBySignal.hash(state),
            }
        }
    }
}

impl CommandErr {

    pub fn unwrap_ExitCode(mut self) -> i32 {
        debug_assert_eq!(self.discriminant, discriminant_CommandErr::ExitCode);
        unsafe { self.payload.ExitCode }
    }

    pub fn is_ExitCode(&self) -> bool {
        matches!(self.discriminant, discriminant_CommandErr::ExitCode)
    }

    pub fn unwrap_IOError(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_CommandErr::IOError);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.IOError) }
    }

    pub fn is_IOError(&self) -> bool {
        matches!(self.discriminant, discriminant_CommandErr::IOError)
    }

    pub fn is_KilledBySignal(&self) -> bool {
        matches!(self.discriminant, discriminant_CommandErr::KilledBySignal)
    }
}



impl CommandErr {

    pub fn ExitCode(payload: i32) -> Self {
        Self {
            discriminant: discriminant_CommandErr::ExitCode,
            payload: union_CommandErr {
                ExitCode: payload,
            }
        }
    }

    pub fn IOError(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_CommandErr::IOError,
            payload: union_CommandErr {
                IOError: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn KilledBySignal() -> Self {
        Self {
            discriminant: discriminant_CommandErr::KilledBySignal,
            payload: union_CommandErr {
                KilledBySignal: (),
            }
        }
    }
}

impl Drop for CommandErr {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_CommandErr::ExitCode => {}
            discriminant_CommandErr::IOError => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.IOError) },
            discriminant_CommandErr::KilledBySignal => {}
        }
    }
}

#[derive(Clone, Default, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct Command {
    pub args: roc_std::RocList<roc_std::RocStr>,
    pub envs: roc_std::RocList<roc_std::RocStr>,
    pub program: roc_std::RocStr,
    pub clearEnvs: bool,
}

#[derive(Clone, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct Output {
    pub status: roc_std::RocResult<(), CommandErr>,
    pub stderr: roc_std::RocList<u8>,
    pub stdout: roc_std::RocList<u8>,
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_IOError {
    AddrInUse = 0,
    AddrNotAvailable = 1,
    AlreadyExists = 2,
    ArgumentListTooLong = 3,
    BrokenPipe = 4,
    ConnectionAborted = 5,
    ConnectionRefused = 6,
    ConnectionReset = 7,
    CrossesDevices = 8,
    Deadlock = 9,
    DirectoryNotEmpty = 10,
    ExecutableFileBusy = 11,
    FileTooLarge = 12,
    FilesystemLoop = 13,
    FilesystemQuotaExceeded = 14,
    HostUnreachable = 15,
    Interrupted = 16,
    InvalidData = 17,
    InvalidFilename = 18,
    InvalidInput = 19,
    IsADirectory = 20,
    NetworkDown = 21,
    NetworkUnreachable = 22,
    NotADirectory = 23,
    NotConnected = 24,
    NotFound = 25,
    NotSeekable = 26,
    Other = 27,
    OutOfMemory = 28,
    PermissionDenied = 29,
    ReadOnlyFilesystem = 30,
    ResourceBusy = 31,
    StaleNetworkFileHandle = 32,
    StorageFull = 33,
    TimedOut = 34,
    TooManyLinks = 35,
    UnexpectedEof = 36,
    Unsupported = 37,
    WouldBlock = 38,
    WriteZero = 39,
}

impl core::fmt::Debug for discriminant_IOError {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::AddrInUse => f.write_str("discriminant_IOError::AddrInUse"),
            Self::AddrNotAvailable => f.write_str("discriminant_IOError::AddrNotAvailable"),
            Self::AlreadyExists => f.write_str("discriminant_IOError::AlreadyExists"),
            Self::ArgumentListTooLong => f.write_str("discriminant_IOError::ArgumentListTooLong"),
            Self::BrokenPipe => f.write_str("discriminant_IOError::BrokenPipe"),
            Self::ConnectionAborted => f.write_str("discriminant_IOError::ConnectionAborted"),
            Self::ConnectionRefused => f.write_str("discriminant_IOError::ConnectionRefused"),
            Self::ConnectionReset => f.write_str("discriminant_IOError::ConnectionReset"),
            Self::CrossesDevices => f.write_str("discriminant_IOError::CrossesDevices"),
            Self::Deadlock => f.write_str("discriminant_IOError::Deadlock"),
            Self::DirectoryNotEmpty => f.write_str("discriminant_IOError::DirectoryNotEmpty"),
            Self::ExecutableFileBusy => f.write_str("discriminant_IOError::ExecutableFileBusy"),
            Self::FileTooLarge => f.write_str("discriminant_IOError::FileTooLarge"),
            Self::FilesystemLoop => f.write_str("discriminant_IOError::FilesystemLoop"),
            Self::FilesystemQuotaExceeded => f.write_str("discriminant_IOError::FilesystemQuotaExceeded"),
            Self::HostUnreachable => f.write_str("discriminant_IOError::HostUnreachable"),
            Self::Interrupted => f.write_str("discriminant_IOError::Interrupted"),
            Self::InvalidData => f.write_str("discriminant_IOError::InvalidData"),
            Self::InvalidFilename => f.write_str("discriminant_IOError::InvalidFilename"),
            Self::InvalidInput => f.write_str("discriminant_IOError::InvalidInput"),
            Self::IsADirectory => f.write_str("discriminant_IOError::IsADirectory"),
            Self::NetworkDown => f.write_str("discriminant_IOError::NetworkDown"),
            Self::NetworkUnreachable => f.write_str("discriminant_IOError::NetworkUnreachable"),
            Self::NotADirectory => f.write_str("discriminant_IOError::NotADirectory"),
            Self::NotConnected => f.write_str("discriminant_IOError::NotConnected"),
            Self::NotFound => f.write_str("discriminant_IOError::NotFound"),
            Self::NotSeekable => f.write_str("discriminant_IOError::NotSeekable"),
            Self::Other => f.write_str("discriminant_IOError::Other"),
            Self::OutOfMemory => f.write_str("discriminant_IOError::OutOfMemory"),
            Self::PermissionDenied => f.write_str("discriminant_IOError::PermissionDenied"),
            Self::ReadOnlyFilesystem => f.write_str("discriminant_IOError::ReadOnlyFilesystem"),
            Self::ResourceBusy => f.write_str("discriminant_IOError::ResourceBusy"),
            Self::StaleNetworkFileHandle => f.write_str("discriminant_IOError::StaleNetworkFileHandle"),
            Self::StorageFull => f.write_str("discriminant_IOError::StorageFull"),
            Self::TimedOut => f.write_str("discriminant_IOError::TimedOut"),
            Self::TooManyLinks => f.write_str("discriminant_IOError::TooManyLinks"),
            Self::UnexpectedEof => f.write_str("discriminant_IOError::UnexpectedEof"),
            Self::Unsupported => f.write_str("discriminant_IOError::Unsupported"),
            Self::WouldBlock => f.write_str("discriminant_IOError::WouldBlock"),
            Self::WriteZero => f.write_str("discriminant_IOError::WriteZero"),
        }
    }
}

#[repr(C, align(1))]
pub union union_IOError {
    AddrInUse: (),
    AddrNotAvailable: (),
    AlreadyExists: (),
    ArgumentListTooLong: (),
    BrokenPipe: (),
    ConnectionAborted: (),
    ConnectionRefused: (),
    ConnectionReset: (),
    CrossesDevices: (),
    Deadlock: (),
    DirectoryNotEmpty: (),
    ExecutableFileBusy: (),
    FileTooLarge: (),
    FilesystemLoop: (),
    FilesystemQuotaExceeded: (),
    HostUnreachable: (),
    Interrupted: (),
    InvalidData: (),
    InvalidFilename: (),
    InvalidInput: (),
    IsADirectory: (),
    NetworkDown: (),
    NetworkUnreachable: (),
    NotADirectory: (),
    NotConnected: (),
    NotFound: (),
    NotSeekable: (),
    Other: (),
    OutOfMemory: (),
    PermissionDenied: (),
    ReadOnlyFilesystem: (),
    ResourceBusy: (),
    StaleNetworkFileHandle: (),
    StorageFull: (),
    TimedOut: (),
    TooManyLinks: (),
    UnexpectedEof: (),
    Unsupported: (),
    WouldBlock: (),
    WriteZero: (),
}

const _SIZE_CHECK_union_IOError: () = assert!(core::mem::size_of::<union_IOError>() == 1);
const _ALIGN_CHECK_union_IOError: () = assert!(core::mem::align_of::<union_IOError>() == 1);

const _SIZE_CHECK_IOError: () = assert!(core::mem::size_of::<IOError>() == 1);
const _ALIGN_CHECK_IOError: () = assert!(core::mem::align_of::<IOError>() == 1);

impl IOError {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_IOError {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_IOError>(*bytes.as_ptr().add(0))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_IOError) {
        let discriminant_ptr: *mut discriminant_IOError = (self as *mut IOError).cast();

        unsafe {
            *(discriminant_ptr.add(0)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct IOError {
    payload: union_IOError,
    discriminant: discriminant_IOError,
}

impl Clone for IOError {
    fn clone(&self) -> Self {
        use discriminant_IOError::*;

        let payload = unsafe {
            match self.discriminant {
                AddrInUse => union_IOError {
                    AddrInUse: self.payload.AddrInUse.clone(),
                },
                AddrNotAvailable => union_IOError {
                    AddrNotAvailable: self.payload.AddrNotAvailable.clone(),
                },
                AlreadyExists => union_IOError {
                    AlreadyExists: self.payload.AlreadyExists.clone(),
                },
                ArgumentListTooLong => union_IOError {
                    ArgumentListTooLong: self.payload.ArgumentListTooLong.clone(),
                },
                BrokenPipe => union_IOError {
                    BrokenPipe: self.payload.BrokenPipe.clone(),
                },
                ConnectionAborted => union_IOError {
                    ConnectionAborted: self.payload.ConnectionAborted.clone(),
                },
                ConnectionRefused => union_IOError {
                    ConnectionRefused: self.payload.ConnectionRefused.clone(),
                },
                ConnectionReset => union_IOError {
                    ConnectionReset: self.payload.ConnectionReset.clone(),
                },
                CrossesDevices => union_IOError {
                    CrossesDevices: self.payload.CrossesDevices.clone(),
                },
                Deadlock => union_IOError {
                    Deadlock: self.payload.Deadlock.clone(),
                },
                DirectoryNotEmpty => union_IOError {
                    DirectoryNotEmpty: self.payload.DirectoryNotEmpty.clone(),
                },
                ExecutableFileBusy => union_IOError {
                    ExecutableFileBusy: self.payload.ExecutableFileBusy.clone(),
                },
                FileTooLarge => union_IOError {
                    FileTooLarge: self.payload.FileTooLarge.clone(),
                },
                FilesystemLoop => union_IOError {
                    FilesystemLoop: self.payload.FilesystemLoop.clone(),
                },
                FilesystemQuotaExceeded => union_IOError {
                    FilesystemQuotaExceeded: self.payload.FilesystemQuotaExceeded.clone(),
                },
                HostUnreachable => union_IOError {
                    HostUnreachable: self.payload.HostUnreachable.clone(),
                },
                Interrupted => union_IOError {
                    Interrupted: self.payload.Interrupted.clone(),
                },
                InvalidData => union_IOError {
                    InvalidData: self.payload.InvalidData.clone(),
                },
                InvalidFilename => union_IOError {
                    InvalidFilename: self.payload.InvalidFilename.clone(),
                },
                InvalidInput => union_IOError {
                    InvalidInput: self.payload.InvalidInput.clone(),
                },
                IsADirectory => union_IOError {
                    IsADirectory: self.payload.IsADirectory.clone(),
                },
                NetworkDown => union_IOError {
                    NetworkDown: self.payload.NetworkDown.clone(),
                },
                NetworkUnreachable => union_IOError {
                    NetworkUnreachable: self.payload.NetworkUnreachable.clone(),
                },
                NotADirectory => union_IOError {
                    NotADirectory: self.payload.NotADirectory.clone(),
                },
                NotConnected => union_IOError {
                    NotConnected: self.payload.NotConnected.clone(),
                },
                NotFound => union_IOError {
                    NotFound: self.payload.NotFound.clone(),
                },
                NotSeekable => union_IOError {
                    NotSeekable: self.payload.NotSeekable.clone(),
                },
                Other => union_IOError {
                    Other: self.payload.Other.clone(),
                },
                OutOfMemory => union_IOError {
                    OutOfMemory: self.payload.OutOfMemory.clone(),
                },
                PermissionDenied => union_IOError {
                    PermissionDenied: self.payload.PermissionDenied.clone(),
                },
                ReadOnlyFilesystem => union_IOError {
                    ReadOnlyFilesystem: self.payload.ReadOnlyFilesystem.clone(),
                },
                ResourceBusy => union_IOError {
                    ResourceBusy: self.payload.ResourceBusy.clone(),
                },
                StaleNetworkFileHandle => union_IOError {
                    StaleNetworkFileHandle: self.payload.StaleNetworkFileHandle.clone(),
                },
                StorageFull => union_IOError {
                    StorageFull: self.payload.StorageFull.clone(),
                },
                TimedOut => union_IOError {
                    TimedOut: self.payload.TimedOut.clone(),
                },
                TooManyLinks => union_IOError {
                    TooManyLinks: self.payload.TooManyLinks.clone(),
                },
                UnexpectedEof => union_IOError {
                    UnexpectedEof: self.payload.UnexpectedEof.clone(),
                },
                Unsupported => union_IOError {
                    Unsupported: self.payload.Unsupported.clone(),
                },
                WouldBlock => union_IOError {
                    WouldBlock: self.payload.WouldBlock.clone(),
                },
                WriteZero => union_IOError {
                    WriteZero: self.payload.WriteZero.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for IOError {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_IOError::*;

        unsafe {
            match self.discriminant {
                AddrInUse => {
                    let field: &() = &self.payload.AddrInUse;
                    f.debug_tuple("IOError::AddrInUse").field(field).finish()
                },
                AddrNotAvailable => {
                    let field: &() = &self.payload.AddrNotAvailable;
                    f.debug_tuple("IOError::AddrNotAvailable").field(field).finish()
                },
                AlreadyExists => {
                    let field: &() = &self.payload.AlreadyExists;
                    f.debug_tuple("IOError::AlreadyExists").field(field).finish()
                },
                ArgumentListTooLong => {
                    let field: &() = &self.payload.ArgumentListTooLong;
                    f.debug_tuple("IOError::ArgumentListTooLong").field(field).finish()
                },
                BrokenPipe => {
                    let field: &() = &self.payload.BrokenPipe;
                    f.debug_tuple("IOError::BrokenPipe").field(field).finish()
                },
                ConnectionAborted => {
                    let field: &() = &self.payload.ConnectionAborted;
                    f.debug_tuple("IOError::ConnectionAborted").field(field).finish()
                },
                ConnectionRefused => {
                    let field: &() = &self.payload.ConnectionRefused;
                    f.debug_tuple("IOError::ConnectionRefused").field(field).finish()
                },
                ConnectionReset => {
                    let field: &() = &self.payload.ConnectionReset;
                    f.debug_tuple("IOError::ConnectionReset").field(field).finish()
                },
                CrossesDevices => {
                    let field: &() = &self.payload.CrossesDevices;
                    f.debug_tuple("IOError::CrossesDevices").field(field).finish()
                },
                Deadlock => {
                    let field: &() = &self.payload.Deadlock;
                    f.debug_tuple("IOError::Deadlock").field(field).finish()
                },
                DirectoryNotEmpty => {
                    let field: &() = &self.payload.DirectoryNotEmpty;
                    f.debug_tuple("IOError::DirectoryNotEmpty").field(field).finish()
                },
                ExecutableFileBusy => {
                    let field: &() = &self.payload.ExecutableFileBusy;
                    f.debug_tuple("IOError::ExecutableFileBusy").field(field).finish()
                },
                FileTooLarge => {
                    let field: &() = &self.payload.FileTooLarge;
                    f.debug_tuple("IOError::FileTooLarge").field(field).finish()
                },
                FilesystemLoop => {
                    let field: &() = &self.payload.FilesystemLoop;
                    f.debug_tuple("IOError::FilesystemLoop").field(field).finish()
                },
                FilesystemQuotaExceeded => {
                    let field: &() = &self.payload.FilesystemQuotaExceeded;
                    f.debug_tuple("IOError::FilesystemQuotaExceeded").field(field).finish()
                },
                HostUnreachable => {
                    let field: &() = &self.payload.HostUnreachable;
                    f.debug_tuple("IOError::HostUnreachable").field(field).finish()
                },
                Interrupted => {
                    let field: &() = &self.payload.Interrupted;
                    f.debug_tuple("IOError::Interrupted").field(field).finish()
                },
                InvalidData => {
                    let field: &() = &self.payload.InvalidData;
                    f.debug_tuple("IOError::InvalidData").field(field).finish()
                },
                InvalidFilename => {
                    let field: &() = &self.payload.InvalidFilename;
                    f.debug_tuple("IOError::InvalidFilename").field(field).finish()
                },
                InvalidInput => {
                    let field: &() = &self.payload.InvalidInput;
                    f.debug_tuple("IOError::InvalidInput").field(field).finish()
                },
                IsADirectory => {
                    let field: &() = &self.payload.IsADirectory;
                    f.debug_tuple("IOError::IsADirectory").field(field).finish()
                },
                NetworkDown => {
                    let field: &() = &self.payload.NetworkDown;
                    f.debug_tuple("IOError::NetworkDown").field(field).finish()
                },
                NetworkUnreachable => {
                    let field: &() = &self.payload.NetworkUnreachable;
                    f.debug_tuple("IOError::NetworkUnreachable").field(field).finish()
                },
                NotADirectory => {
                    let field: &() = &self.payload.NotADirectory;
                    f.debug_tuple("IOError::NotADirectory").field(field).finish()
                },
                NotConnected => {
                    let field: &() = &self.payload.NotConnected;
                    f.debug_tuple("IOError::NotConnected").field(field).finish()
                },
                NotFound => {
                    let field: &() = &self.payload.NotFound;
                    f.debug_tuple("IOError::NotFound").field(field).finish()
                },
                NotSeekable => {
                    let field: &() = &self.payload.NotSeekable;
                    f.debug_tuple("IOError::NotSeekable").field(field).finish()
                },
                Other => {
                    let field: &() = &self.payload.Other;
                    f.debug_tuple("IOError::Other").field(field).finish()
                },
                OutOfMemory => {
                    let field: &() = &self.payload.OutOfMemory;
                    f.debug_tuple("IOError::OutOfMemory").field(field).finish()
                },
                PermissionDenied => {
                    let field: &() = &self.payload.PermissionDenied;
                    f.debug_tuple("IOError::PermissionDenied").field(field).finish()
                },
                ReadOnlyFilesystem => {
                    let field: &() = &self.payload.ReadOnlyFilesystem;
                    f.debug_tuple("IOError::ReadOnlyFilesystem").field(field).finish()
                },
                ResourceBusy => {
                    let field: &() = &self.payload.ResourceBusy;
                    f.debug_tuple("IOError::ResourceBusy").field(field).finish()
                },
                StaleNetworkFileHandle => {
                    let field: &() = &self.payload.StaleNetworkFileHandle;
                    f.debug_tuple("IOError::StaleNetworkFileHandle").field(field).finish()
                },
                StorageFull => {
                    let field: &() = &self.payload.StorageFull;
                    f.debug_tuple("IOError::StorageFull").field(field).finish()
                },
                TimedOut => {
                    let field: &() = &self.payload.TimedOut;
                    f.debug_tuple("IOError::TimedOut").field(field).finish()
                },
                TooManyLinks => {
                    let field: &() = &self.payload.TooManyLinks;
                    f.debug_tuple("IOError::TooManyLinks").field(field).finish()
                },
                UnexpectedEof => {
                    let field: &() = &self.payload.UnexpectedEof;
                    f.debug_tuple("IOError::UnexpectedEof").field(field).finish()
                },
                Unsupported => {
                    let field: &() = &self.payload.Unsupported;
                    f.debug_tuple("IOError::Unsupported").field(field).finish()
                },
                WouldBlock => {
                    let field: &() = &self.payload.WouldBlock;
                    f.debug_tuple("IOError::WouldBlock").field(field).finish()
                },
                WriteZero => {
                    let field: &() = &self.payload.WriteZero;
                    f.debug_tuple("IOError::WriteZero").field(field).finish()
                },
            }
        }
    }
}

impl Eq for IOError {}

impl PartialEq for IOError {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_IOError::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                AddrInUse => self.payload.AddrInUse == other.payload.AddrInUse,
                AddrNotAvailable => self.payload.AddrNotAvailable == other.payload.AddrNotAvailable,
                AlreadyExists => self.payload.AlreadyExists == other.payload.AlreadyExists,
                ArgumentListTooLong => self.payload.ArgumentListTooLong == other.payload.ArgumentListTooLong,
                BrokenPipe => self.payload.BrokenPipe == other.payload.BrokenPipe,
                ConnectionAborted => self.payload.ConnectionAborted == other.payload.ConnectionAborted,
                ConnectionRefused => self.payload.ConnectionRefused == other.payload.ConnectionRefused,
                ConnectionReset => self.payload.ConnectionReset == other.payload.ConnectionReset,
                CrossesDevices => self.payload.CrossesDevices == other.payload.CrossesDevices,
                Deadlock => self.payload.Deadlock == other.payload.Deadlock,
                DirectoryNotEmpty => self.payload.DirectoryNotEmpty == other.payload.DirectoryNotEmpty,
                ExecutableFileBusy => self.payload.ExecutableFileBusy == other.payload.ExecutableFileBusy,
                FileTooLarge => self.payload.FileTooLarge == other.payload.FileTooLarge,
                FilesystemLoop => self.payload.FilesystemLoop == other.payload.FilesystemLoop,
                FilesystemQuotaExceeded => self.payload.FilesystemQuotaExceeded == other.payload.FilesystemQuotaExceeded,
                HostUnreachable => self.payload.HostUnreachable == other.payload.HostUnreachable,
                Interrupted => self.payload.Interrupted == other.payload.Interrupted,
                InvalidData => self.payload.InvalidData == other.payload.InvalidData,
                InvalidFilename => self.payload.InvalidFilename == other.payload.InvalidFilename,
                InvalidInput => self.payload.InvalidInput == other.payload.InvalidInput,
                IsADirectory => self.payload.IsADirectory == other.payload.IsADirectory,
                NetworkDown => self.payload.NetworkDown == other.payload.NetworkDown,
                NetworkUnreachable => self.payload.NetworkUnreachable == other.payload.NetworkUnreachable,
                NotADirectory => self.payload.NotADirectory == other.payload.NotADirectory,
                NotConnected => self.payload.NotConnected == other.payload.NotConnected,
                NotFound => self.payload.NotFound == other.payload.NotFound,
                NotSeekable => self.payload.NotSeekable == other.payload.NotSeekable,
                Other => self.payload.Other == other.payload.Other,
                OutOfMemory => self.payload.OutOfMemory == other.payload.OutOfMemory,
                PermissionDenied => self.payload.PermissionDenied == other.payload.PermissionDenied,
                ReadOnlyFilesystem => self.payload.ReadOnlyFilesystem == other.payload.ReadOnlyFilesystem,
                ResourceBusy => self.payload.ResourceBusy == other.payload.ResourceBusy,
                StaleNetworkFileHandle => self.payload.StaleNetworkFileHandle == other.payload.StaleNetworkFileHandle,
                StorageFull => self.payload.StorageFull == other.payload.StorageFull,
                TimedOut => self.payload.TimedOut == other.payload.TimedOut,
                TooManyLinks => self.payload.TooManyLinks == other.payload.TooManyLinks,
                UnexpectedEof => self.payload.UnexpectedEof == other.payload.UnexpectedEof,
                Unsupported => self.payload.Unsupported == other.payload.Unsupported,
                WouldBlock => self.payload.WouldBlock == other.payload.WouldBlock,
                WriteZero => self.payload.WriteZero == other.payload.WriteZero,
            }
        }
    }
}

impl Ord for IOError {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for IOError {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_IOError::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    AddrInUse => self.payload.AddrInUse.partial_cmp(&other.payload.AddrInUse),
                    AddrNotAvailable => self.payload.AddrNotAvailable.partial_cmp(&other.payload.AddrNotAvailable),
                    AlreadyExists => self.payload.AlreadyExists.partial_cmp(&other.payload.AlreadyExists),
                    ArgumentListTooLong => self.payload.ArgumentListTooLong.partial_cmp(&other.payload.ArgumentListTooLong),
                    BrokenPipe => self.payload.BrokenPipe.partial_cmp(&other.payload.BrokenPipe),
                    ConnectionAborted => self.payload.ConnectionAborted.partial_cmp(&other.payload.ConnectionAborted),
                    ConnectionRefused => self.payload.ConnectionRefused.partial_cmp(&other.payload.ConnectionRefused),
                    ConnectionReset => self.payload.ConnectionReset.partial_cmp(&other.payload.ConnectionReset),
                    CrossesDevices => self.payload.CrossesDevices.partial_cmp(&other.payload.CrossesDevices),
                    Deadlock => self.payload.Deadlock.partial_cmp(&other.payload.Deadlock),
                    DirectoryNotEmpty => self.payload.DirectoryNotEmpty.partial_cmp(&other.payload.DirectoryNotEmpty),
                    ExecutableFileBusy => self.payload.ExecutableFileBusy.partial_cmp(&other.payload.ExecutableFileBusy),
                    FileTooLarge => self.payload.FileTooLarge.partial_cmp(&other.payload.FileTooLarge),
                    FilesystemLoop => self.payload.FilesystemLoop.partial_cmp(&other.payload.FilesystemLoop),
                    FilesystemQuotaExceeded => self.payload.FilesystemQuotaExceeded.partial_cmp(&other.payload.FilesystemQuotaExceeded),
                    HostUnreachable => self.payload.HostUnreachable.partial_cmp(&other.payload.HostUnreachable),
                    Interrupted => self.payload.Interrupted.partial_cmp(&other.payload.Interrupted),
                    InvalidData => self.payload.InvalidData.partial_cmp(&other.payload.InvalidData),
                    InvalidFilename => self.payload.InvalidFilename.partial_cmp(&other.payload.InvalidFilename),
                    InvalidInput => self.payload.InvalidInput.partial_cmp(&other.payload.InvalidInput),
                    IsADirectory => self.payload.IsADirectory.partial_cmp(&other.payload.IsADirectory),
                    NetworkDown => self.payload.NetworkDown.partial_cmp(&other.payload.NetworkDown),
                    NetworkUnreachable => self.payload.NetworkUnreachable.partial_cmp(&other.payload.NetworkUnreachable),
                    NotADirectory => self.payload.NotADirectory.partial_cmp(&other.payload.NotADirectory),
                    NotConnected => self.payload.NotConnected.partial_cmp(&other.payload.NotConnected),
                    NotFound => self.payload.NotFound.partial_cmp(&other.payload.NotFound),
                    NotSeekable => self.payload.NotSeekable.partial_cmp(&other.payload.NotSeekable),
                    Other => self.payload.Other.partial_cmp(&other.payload.Other),
                    OutOfMemory => self.payload.OutOfMemory.partial_cmp(&other.payload.OutOfMemory),
                    PermissionDenied => self.payload.PermissionDenied.partial_cmp(&other.payload.PermissionDenied),
                    ReadOnlyFilesystem => self.payload.ReadOnlyFilesystem.partial_cmp(&other.payload.ReadOnlyFilesystem),
                    ResourceBusy => self.payload.ResourceBusy.partial_cmp(&other.payload.ResourceBusy),
                    StaleNetworkFileHandle => self.payload.StaleNetworkFileHandle.partial_cmp(&other.payload.StaleNetworkFileHandle),
                    StorageFull => self.payload.StorageFull.partial_cmp(&other.payload.StorageFull),
                    TimedOut => self.payload.TimedOut.partial_cmp(&other.payload.TimedOut),
                    TooManyLinks => self.payload.TooManyLinks.partial_cmp(&other.payload.TooManyLinks),
                    UnexpectedEof => self.payload.UnexpectedEof.partial_cmp(&other.payload.UnexpectedEof),
                    Unsupported => self.payload.Unsupported.partial_cmp(&other.payload.Unsupported),
                    WouldBlock => self.payload.WouldBlock.partial_cmp(&other.payload.WouldBlock),
                    WriteZero => self.payload.WriteZero.partial_cmp(&other.payload.WriteZero),
                }
            },
        }
    }
}

impl core::hash::Hash for IOError {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_IOError::*;

        unsafe {
            match self.discriminant {
                AddrInUse => self.payload.AddrInUse.hash(state),
                AddrNotAvailable => self.payload.AddrNotAvailable.hash(state),
                AlreadyExists => self.payload.AlreadyExists.hash(state),
                ArgumentListTooLong => self.payload.ArgumentListTooLong.hash(state),
                BrokenPipe => self.payload.BrokenPipe.hash(state),
                ConnectionAborted => self.payload.ConnectionAborted.hash(state),
                ConnectionRefused => self.payload.ConnectionRefused.hash(state),
                ConnectionReset => self.payload.ConnectionReset.hash(state),
                CrossesDevices => self.payload.CrossesDevices.hash(state),
                Deadlock => self.payload.Deadlock.hash(state),
                DirectoryNotEmpty => self.payload.DirectoryNotEmpty.hash(state),
                ExecutableFileBusy => self.payload.ExecutableFileBusy.hash(state),
                FileTooLarge => self.payload.FileTooLarge.hash(state),
                FilesystemLoop => self.payload.FilesystemLoop.hash(state),
                FilesystemQuotaExceeded => self.payload.FilesystemQuotaExceeded.hash(state),
                HostUnreachable => self.payload.HostUnreachable.hash(state),
                Interrupted => self.payload.Interrupted.hash(state),
                InvalidData => self.payload.InvalidData.hash(state),
                InvalidFilename => self.payload.InvalidFilename.hash(state),
                InvalidInput => self.payload.InvalidInput.hash(state),
                IsADirectory => self.payload.IsADirectory.hash(state),
                NetworkDown => self.payload.NetworkDown.hash(state),
                NetworkUnreachable => self.payload.NetworkUnreachable.hash(state),
                NotADirectory => self.payload.NotADirectory.hash(state),
                NotConnected => self.payload.NotConnected.hash(state),
                NotFound => self.payload.NotFound.hash(state),
                NotSeekable => self.payload.NotSeekable.hash(state),
                Other => self.payload.Other.hash(state),
                OutOfMemory => self.payload.OutOfMemory.hash(state),
                PermissionDenied => self.payload.PermissionDenied.hash(state),
                ReadOnlyFilesystem => self.payload.ReadOnlyFilesystem.hash(state),
                ResourceBusy => self.payload.ResourceBusy.hash(state),
                StaleNetworkFileHandle => self.payload.StaleNetworkFileHandle.hash(state),
                StorageFull => self.payload.StorageFull.hash(state),
                TimedOut => self.payload.TimedOut.hash(state),
                TooManyLinks => self.payload.TooManyLinks.hash(state),
                UnexpectedEof => self.payload.UnexpectedEof.hash(state),
                Unsupported => self.payload.Unsupported.hash(state),
                WouldBlock => self.payload.WouldBlock.hash(state),
                WriteZero => self.payload.WriteZero.hash(state),
            }
        }
    }
}

impl IOError {

    pub fn is_AddrInUse(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::AddrInUse)
    }

    pub fn is_AddrNotAvailable(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::AddrNotAvailable)
    }

    pub fn is_AlreadyExists(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::AlreadyExists)
    }

    pub fn is_ArgumentListTooLong(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::ArgumentListTooLong)
    }

    pub fn is_BrokenPipe(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::BrokenPipe)
    }

    pub fn is_ConnectionAborted(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::ConnectionAborted)
    }

    pub fn is_ConnectionRefused(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::ConnectionRefused)
    }

    pub fn is_ConnectionReset(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::ConnectionReset)
    }

    pub fn is_CrossesDevices(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::CrossesDevices)
    }

    pub fn is_Deadlock(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::Deadlock)
    }

    pub fn is_DirectoryNotEmpty(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::DirectoryNotEmpty)
    }

    pub fn is_ExecutableFileBusy(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::ExecutableFileBusy)
    }

    pub fn is_FileTooLarge(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::FileTooLarge)
    }

    pub fn is_FilesystemLoop(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::FilesystemLoop)
    }

    pub fn is_FilesystemQuotaExceeded(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::FilesystemQuotaExceeded)
    }

    pub fn is_HostUnreachable(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::HostUnreachable)
    }

    pub fn is_Interrupted(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::Interrupted)
    }

    pub fn is_InvalidData(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::InvalidData)
    }

    pub fn is_InvalidFilename(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::InvalidFilename)
    }

    pub fn is_InvalidInput(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::InvalidInput)
    }

    pub fn is_IsADirectory(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::IsADirectory)
    }

    pub fn is_NetworkDown(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::NetworkDown)
    }

    pub fn is_NetworkUnreachable(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::NetworkUnreachable)
    }

    pub fn is_NotADirectory(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::NotADirectory)
    }

    pub fn is_NotConnected(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::NotConnected)
    }

    pub fn is_NotFound(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::NotFound)
    }

    pub fn is_NotSeekable(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::NotSeekable)
    }

    pub fn is_Other(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::Other)
    }

    pub fn is_OutOfMemory(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::OutOfMemory)
    }

    pub fn is_PermissionDenied(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::PermissionDenied)
    }

    pub fn is_ReadOnlyFilesystem(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::ReadOnlyFilesystem)
    }

    pub fn is_ResourceBusy(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::ResourceBusy)
    }

    pub fn is_StaleNetworkFileHandle(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::StaleNetworkFileHandle)
    }

    pub fn is_StorageFull(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::StorageFull)
    }

    pub fn is_TimedOut(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::TimedOut)
    }

    pub fn is_TooManyLinks(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::TooManyLinks)
    }

    pub fn is_UnexpectedEof(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::UnexpectedEof)
    }

    pub fn is_Unsupported(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::Unsupported)
    }

    pub fn is_WouldBlock(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::WouldBlock)
    }

    pub fn is_WriteZero(&self) -> bool {
        matches!(self.discriminant, discriminant_IOError::WriteZero)
    }
}



impl IOError {

    pub fn AddrInUse() -> Self {
        Self {
            discriminant: discriminant_IOError::AddrInUse,
            payload: union_IOError {
                AddrInUse: (),
            }
        }
    }

    pub fn AddrNotAvailable() -> Self {
        Self {
            discriminant: discriminant_IOError::AddrNotAvailable,
            payload: union_IOError {
                AddrNotAvailable: (),
            }
        }
    }

    pub fn AlreadyExists() -> Self {
        Self {
            discriminant: discriminant_IOError::AlreadyExists,
            payload: union_IOError {
                AlreadyExists: (),
            }
        }
    }

    pub fn ArgumentListTooLong() -> Self {
        Self {
            discriminant: discriminant_IOError::ArgumentListTooLong,
            payload: union_IOError {
                ArgumentListTooLong: (),
            }
        }
    }

    pub fn BrokenPipe() -> Self {
        Self {
            discriminant: discriminant_IOError::BrokenPipe,
            payload: union_IOError {
                BrokenPipe: (),
            }
        }
    }

    pub fn ConnectionAborted() -> Self {
        Self {
            discriminant: discriminant_IOError::ConnectionAborted,
            payload: union_IOError {
                ConnectionAborted: (),
            }
        }
    }

    pub fn ConnectionRefused() -> Self {
        Self {
            discriminant: discriminant_IOError::ConnectionRefused,
            payload: union_IOError {
                ConnectionRefused: (),
            }
        }
    }

    pub fn ConnectionReset() -> Self {
        Self {
            discriminant: discriminant_IOError::ConnectionReset,
            payload: union_IOError {
                ConnectionReset: (),
            }
        }
    }

    pub fn CrossesDevices() -> Self {
        Self {
            discriminant: discriminant_IOError::CrossesDevices,
            payload: union_IOError {
                CrossesDevices: (),
            }
        }
    }

    pub fn Deadlock() -> Self {
        Self {
            discriminant: discriminant_IOError::Deadlock,
            payload: union_IOError {
                Deadlock: (),
            }
        }
    }

    pub fn DirectoryNotEmpty() -> Self {
        Self {
            discriminant: discriminant_IOError::DirectoryNotEmpty,
            payload: union_IOError {
                DirectoryNotEmpty: (),
            }
        }
    }

    pub fn ExecutableFileBusy() -> Self {
        Self {
            discriminant: discriminant_IOError::ExecutableFileBusy,
            payload: union_IOError {
                ExecutableFileBusy: (),
            }
        }
    }

    pub fn FileTooLarge() -> Self {
        Self {
            discriminant: discriminant_IOError::FileTooLarge,
            payload: union_IOError {
                FileTooLarge: (),
            }
        }
    }

    pub fn FilesystemLoop() -> Self {
        Self {
            discriminant: discriminant_IOError::FilesystemLoop,
            payload: union_IOError {
                FilesystemLoop: (),
            }
        }
    }

    pub fn FilesystemQuotaExceeded() -> Self {
        Self {
            discriminant: discriminant_IOError::FilesystemQuotaExceeded,
            payload: union_IOError {
                FilesystemQuotaExceeded: (),
            }
        }
    }

    pub fn HostUnreachable() -> Self {
        Self {
            discriminant: discriminant_IOError::HostUnreachable,
            payload: union_IOError {
                HostUnreachable: (),
            }
        }
    }

    pub fn Interrupted() -> Self {
        Self {
            discriminant: discriminant_IOError::Interrupted,
            payload: union_IOError {
                Interrupted: (),
            }
        }
    }

    pub fn InvalidData() -> Self {
        Self {
            discriminant: discriminant_IOError::InvalidData,
            payload: union_IOError {
                InvalidData: (),
            }
        }
    }

    pub fn InvalidFilename() -> Self {
        Self {
            discriminant: discriminant_IOError::InvalidFilename,
            payload: union_IOError {
                InvalidFilename: (),
            }
        }
    }

    pub fn InvalidInput() -> Self {
        Self {
            discriminant: discriminant_IOError::InvalidInput,
            payload: union_IOError {
                InvalidInput: (),
            }
        }
    }

    pub fn IsADirectory() -> Self {
        Self {
            discriminant: discriminant_IOError::IsADirectory,
            payload: union_IOError {
                IsADirectory: (),
            }
        }
    }

    pub fn NetworkDown() -> Self {
        Self {
            discriminant: discriminant_IOError::NetworkDown,
            payload: union_IOError {
                NetworkDown: (),
            }
        }
    }

    pub fn NetworkUnreachable() -> Self {
        Self {
            discriminant: discriminant_IOError::NetworkUnreachable,
            payload: union_IOError {
                NetworkUnreachable: (),
            }
        }
    }

    pub fn NotADirectory() -> Self {
        Self {
            discriminant: discriminant_IOError::NotADirectory,
            payload: union_IOError {
                NotADirectory: (),
            }
        }
    }

    pub fn NotConnected() -> Self {
        Self {
            discriminant: discriminant_IOError::NotConnected,
            payload: union_IOError {
                NotConnected: (),
            }
        }
    }

    pub fn NotFound() -> Self {
        Self {
            discriminant: discriminant_IOError::NotFound,
            payload: union_IOError {
                NotFound: (),
            }
        }
    }

    pub fn NotSeekable() -> Self {
        Self {
            discriminant: discriminant_IOError::NotSeekable,
            payload: union_IOError {
                NotSeekable: (),
            }
        }
    }

    pub fn Other() -> Self {
        Self {
            discriminant: discriminant_IOError::Other,
            payload: union_IOError {
                Other: (),
            }
        }
    }

    pub fn OutOfMemory() -> Self {
        Self {
            discriminant: discriminant_IOError::OutOfMemory,
            payload: union_IOError {
                OutOfMemory: (),
            }
        }
    }

    pub fn PermissionDenied() -> Self {
        Self {
            discriminant: discriminant_IOError::PermissionDenied,
            payload: union_IOError {
                PermissionDenied: (),
            }
        }
    }

    pub fn ReadOnlyFilesystem() -> Self {
        Self {
            discriminant: discriminant_IOError::ReadOnlyFilesystem,
            payload: union_IOError {
                ReadOnlyFilesystem: (),
            }
        }
    }

    pub fn ResourceBusy() -> Self {
        Self {
            discriminant: discriminant_IOError::ResourceBusy,
            payload: union_IOError {
                ResourceBusy: (),
            }
        }
    }

    pub fn StaleNetworkFileHandle() -> Self {
        Self {
            discriminant: discriminant_IOError::StaleNetworkFileHandle,
            payload: union_IOError {
                StaleNetworkFileHandle: (),
            }
        }
    }

    pub fn StorageFull() -> Self {
        Self {
            discriminant: discriminant_IOError::StorageFull,
            payload: union_IOError {
                StorageFull: (),
            }
        }
    }

    pub fn TimedOut() -> Self {
        Self {
            discriminant: discriminant_IOError::TimedOut,
            payload: union_IOError {
                TimedOut: (),
            }
        }
    }

    pub fn TooManyLinks() -> Self {
        Self {
            discriminant: discriminant_IOError::TooManyLinks,
            payload: union_IOError {
                TooManyLinks: (),
            }
        }
    }

    pub fn UnexpectedEof() -> Self {
        Self {
            discriminant: discriminant_IOError::UnexpectedEof,
            payload: union_IOError {
                UnexpectedEof: (),
            }
        }
    }

    pub fn Unsupported() -> Self {
        Self {
            discriminant: discriminant_IOError::Unsupported,
            payload: union_IOError {
                Unsupported: (),
            }
        }
    }

    pub fn WouldBlock() -> Self {
        Self {
            discriminant: discriminant_IOError::WouldBlock,
            payload: union_IOError {
                WouldBlock: (),
            }
        }
    }

    pub fn WriteZero() -> Self {
        Self {
            discriminant: discriminant_IOError::WriteZero,
            payload: union_IOError {
                WriteZero: (),
            }
        }
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_U1 {
    NonUnix = 0,
    Unix = 1,
}

impl core::fmt::Debug for discriminant_U1 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::NonUnix => f.write_str("discriminant_U1::NonUnix"),
            Self::Unix => f.write_str("discriminant_U1::Unix"),
        }
    }
}

#[repr(C, align(4))]
pub union union_U1 {
    NonUnix: (),
    Unix: u32,
}

const _SIZE_CHECK_union_U1: () = assert!(core::mem::size_of::<union_U1>() == 4);
const _ALIGN_CHECK_union_U1: () = assert!(core::mem::align_of::<union_U1>() == 4);

const _SIZE_CHECK_U1: () = assert!(core::mem::size_of::<U1>() == 8);
const _ALIGN_CHECK_U1: () = assert!(core::mem::align_of::<U1>() == 4);

impl U1 {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_U1 {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_U1>(*bytes.as_ptr().add(4))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_U1) {
        let discriminant_ptr: *mut discriminant_U1 = (self as *mut U1).cast();

        unsafe {
            *(discriminant_ptr.add(4)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct U1 {
    payload: union_U1,
    discriminant: discriminant_U1,
}

impl Clone for U1 {
    fn clone(&self) -> Self {
        use discriminant_U1::*;

        let payload = unsafe {
            match self.discriminant {
                NonUnix => union_U1 {
                    NonUnix: self.payload.NonUnix.clone(),
                },
                Unix => union_U1 {
                    Unix: self.payload.Unix.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for U1 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_U1::*;

        unsafe {
            match self.discriminant {
                NonUnix => {
                    let field: &() = &self.payload.NonUnix;
                    f.debug_tuple("U1::NonUnix").field(field).finish()
                },
                Unix => {
                    let field: &u32 = &self.payload.Unix;
                    f.debug_tuple("U1::Unix").field(field).finish()
                },
            }
        }
    }
}

impl Eq for U1 {}

impl PartialEq for U1 {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_U1::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                NonUnix => self.payload.NonUnix == other.payload.NonUnix,
                Unix => self.payload.Unix == other.payload.Unix,
            }
        }
    }
}

impl Ord for U1 {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for U1 {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_U1::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    NonUnix => self.payload.NonUnix.partial_cmp(&other.payload.NonUnix),
                    Unix => self.payload.Unix.partial_cmp(&other.payload.Unix),
                }
            },
        }
    }
}

impl core::hash::Hash for U1 {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_U1::*;

        unsafe {
            match self.discriminant {
                NonUnix => self.payload.NonUnix.hash(state),
                Unix => self.payload.Unix.hash(state),
            }
        }
    }
}

impl U1 {

    pub fn is_NonUnix(&self) -> bool {
        matches!(self.discriminant, discriminant_U1::NonUnix)
    }

    pub fn unwrap_Unix(mut self) -> u32 {
        debug_assert_eq!(self.discriminant, discriminant_U1::Unix);
        unsafe { self.payload.Unix }
    }

    pub fn is_Unix(&self) -> bool {
        matches!(self.discriminant, discriminant_U1::Unix)
    }
}



impl U1 {

    pub fn NonUnix() -> Self {
        Self {
            discriminant: discriminant_U1::NonUnix,
            payload: union_U1 {
                NonUnix: (),
            }
        }
    }

    pub fn Unix(payload: u32) -> Self {
        Self {
            discriminant: discriminant_U1::Unix,
            payload: union_U1 {
                Unix: payload,
            }
        }
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum U2 {
    Dir = 0,
    File = 1,
    Symlink = 2,
}

impl core::fmt::Debug for U2 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Dir => f.write_str("U2::Dir"),
            Self::File => f.write_str("U2::File"),
            Self::Symlink => f.write_str("U2::Symlink"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct FileMetadata {
    pub bytes: u64,
    pub mode: U1,
    pub isReadonly: bool,
    pub r#type: U2,
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_UnwrappedPath {
    ArbitraryBytes = 0,
    FromOperatingSystem = 1,
    FromStr = 2,
}

impl core::fmt::Debug for discriminant_UnwrappedPath {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::ArbitraryBytes => f.write_str("discriminant_UnwrappedPath::ArbitraryBytes"),
            Self::FromOperatingSystem => f.write_str("discriminant_UnwrappedPath::FromOperatingSystem"),
            Self::FromStr => f.write_str("discriminant_UnwrappedPath::FromStr"),
        }
    }
}

#[repr(C, align(4))]
pub union union_UnwrappedPath {
    ArbitraryBytes: core::mem::ManuallyDrop<roc_std::RocList<u8>>,
    FromOperatingSystem: core::mem::ManuallyDrop<roc_std::RocList<u8>>,
    FromStr: core::mem::ManuallyDrop<roc_std::RocStr>,
}

const _SIZE_CHECK_union_UnwrappedPath: () = assert!(core::mem::size_of::<union_UnwrappedPath>() == 12);
const _ALIGN_CHECK_union_UnwrappedPath: () = assert!(core::mem::align_of::<union_UnwrappedPath>() == 4);

const _SIZE_CHECK_UnwrappedPath: () = assert!(core::mem::size_of::<UnwrappedPath>() == 16);
const _ALIGN_CHECK_UnwrappedPath: () = assert!(core::mem::align_of::<UnwrappedPath>() == 4);

impl UnwrappedPath {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_UnwrappedPath {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_UnwrappedPath>(*bytes.as_ptr().add(12))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_UnwrappedPath) {
        let discriminant_ptr: *mut discriminant_UnwrappedPath = (self as *mut UnwrappedPath).cast();

        unsafe {
            *(discriminant_ptr.add(12)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct UnwrappedPath {
    payload: union_UnwrappedPath,
    discriminant: discriminant_UnwrappedPath,
}

impl Clone for UnwrappedPath {
    fn clone(&self) -> Self {
        use discriminant_UnwrappedPath::*;

        let payload = unsafe {
            match self.discriminant {
                ArbitraryBytes => union_UnwrappedPath {
                    ArbitraryBytes: self.payload.ArbitraryBytes.clone(),
                },
                FromOperatingSystem => union_UnwrappedPath {
                    FromOperatingSystem: self.payload.FromOperatingSystem.clone(),
                },
                FromStr => union_UnwrappedPath {
                    FromStr: self.payload.FromStr.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for UnwrappedPath {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_UnwrappedPath::*;

        unsafe {
            match self.discriminant {
                ArbitraryBytes => {
                    let field: &roc_std::RocList<u8> = &self.payload.ArbitraryBytes;
                    f.debug_tuple("UnwrappedPath::ArbitraryBytes").field(field).finish()
                },
                FromOperatingSystem => {
                    let field: &roc_std::RocList<u8> = &self.payload.FromOperatingSystem;
                    f.debug_tuple("UnwrappedPath::FromOperatingSystem").field(field).finish()
                },
                FromStr => {
                    let field: &roc_std::RocStr = &self.payload.FromStr;
                    f.debug_tuple("UnwrappedPath::FromStr").field(field).finish()
                },
            }
        }
    }
}

impl Eq for UnwrappedPath {}

impl PartialEq for UnwrappedPath {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_UnwrappedPath::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                ArbitraryBytes => self.payload.ArbitraryBytes == other.payload.ArbitraryBytes,
                FromOperatingSystem => self.payload.FromOperatingSystem == other.payload.FromOperatingSystem,
                FromStr => self.payload.FromStr == other.payload.FromStr,
            }
        }
    }
}

impl Ord for UnwrappedPath {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for UnwrappedPath {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_UnwrappedPath::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    ArbitraryBytes => self.payload.ArbitraryBytes.partial_cmp(&other.payload.ArbitraryBytes),
                    FromOperatingSystem => self.payload.FromOperatingSystem.partial_cmp(&other.payload.FromOperatingSystem),
                    FromStr => self.payload.FromStr.partial_cmp(&other.payload.FromStr),
                }
            },
        }
    }
}

impl core::hash::Hash for UnwrappedPath {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_UnwrappedPath::*;

        unsafe {
            match self.discriminant {
                ArbitraryBytes => self.payload.ArbitraryBytes.hash(state),
                FromOperatingSystem => self.payload.FromOperatingSystem.hash(state),
                FromStr => self.payload.FromStr.hash(state),
            }
        }
    }
}

impl UnwrappedPath {

    pub fn unwrap_ArbitraryBytes(mut self) -> roc_std::RocList<u8> {
        debug_assert_eq!(self.discriminant, discriminant_UnwrappedPath::ArbitraryBytes);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.ArbitraryBytes) }
    }

    pub fn is_ArbitraryBytes(&self) -> bool {
        matches!(self.discriminant, discriminant_UnwrappedPath::ArbitraryBytes)
    }

    pub fn unwrap_FromOperatingSystem(mut self) -> roc_std::RocList<u8> {
        debug_assert_eq!(self.discriminant, discriminant_UnwrappedPath::FromOperatingSystem);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.FromOperatingSystem) }
    }

    pub fn is_FromOperatingSystem(&self) -> bool {
        matches!(self.discriminant, discriminant_UnwrappedPath::FromOperatingSystem)
    }

    pub fn unwrap_FromStr(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_UnwrappedPath::FromStr);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.FromStr) }
    }

    pub fn is_FromStr(&self) -> bool {
        matches!(self.discriminant, discriminant_UnwrappedPath::FromStr)
    }
}



impl UnwrappedPath {

    pub fn ArbitraryBytes(payload: roc_std::RocList<u8>) -> Self {
        Self {
            discriminant: discriminant_UnwrappedPath::ArbitraryBytes,
            payload: union_UnwrappedPath {
                ArbitraryBytes: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn FromOperatingSystem(payload: roc_std::RocList<u8>) -> Self {
        Self {
            discriminant: discriminant_UnwrappedPath::FromOperatingSystem,
            payload: union_UnwrappedPath {
                FromOperatingSystem: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn FromStr(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_UnwrappedPath::FromStr,
            payload: union_UnwrappedPath {
                FromStr: core::mem::ManuallyDrop::new(payload),
            }
        }
    }
}

impl Drop for UnwrappedPath {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_UnwrappedPath::ArbitraryBytes => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.ArbitraryBytes) },
            discriminant_UnwrappedPath::FromOperatingSystem => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.FromOperatingSystem) },
            discriminant_UnwrappedPath::FromStr => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.FromStr) },
        }
    }
}

#[derive(Clone, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct DirEntry {
    pub metadata: FileMetadata,
    pub path: UnwrappedPath,
    pub r#type: U2,
}

#[derive(Clone, Default, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct ReadErr_Unrecognized {
    pub f0: i32,
    pub f1: roc_std::RocStr,
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_ReadErr {
    Interrupted = 0,
    InvalidFilename = 1,
    NotFound = 2,
    OutOfMemory = 3,
    PermissionDenied = 4,
    StaleNetworkFileHandle = 5,
    TimedOut = 6,
    TooManyHardlinks = 7,
    TooManySymlinks = 8,
    Unrecognized = 9,
    Unsupported = 10,
}

impl core::fmt::Debug for discriminant_ReadErr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Interrupted => f.write_str("discriminant_ReadErr::Interrupted"),
            Self::InvalidFilename => f.write_str("discriminant_ReadErr::InvalidFilename"),
            Self::NotFound => f.write_str("discriminant_ReadErr::NotFound"),
            Self::OutOfMemory => f.write_str("discriminant_ReadErr::OutOfMemory"),
            Self::PermissionDenied => f.write_str("discriminant_ReadErr::PermissionDenied"),
            Self::StaleNetworkFileHandle => f.write_str("discriminant_ReadErr::StaleNetworkFileHandle"),
            Self::TimedOut => f.write_str("discriminant_ReadErr::TimedOut"),
            Self::TooManyHardlinks => f.write_str("discriminant_ReadErr::TooManyHardlinks"),
            Self::TooManySymlinks => f.write_str("discriminant_ReadErr::TooManySymlinks"),
            Self::Unrecognized => f.write_str("discriminant_ReadErr::Unrecognized"),
            Self::Unsupported => f.write_str("discriminant_ReadErr::Unsupported"),
        }
    }
}

#[repr(C, align(4))]
pub union union_ReadErr {
    Interrupted: (),
    InvalidFilename: (),
    NotFound: (),
    OutOfMemory: (),
    PermissionDenied: (),
    StaleNetworkFileHandle: (),
    TimedOut: (),
    TooManyHardlinks: (),
    TooManySymlinks: (),
    Unrecognized: core::mem::ManuallyDrop<ReadErr_Unrecognized>,
    Unsupported: (),
}

const _SIZE_CHECK_union_ReadErr: () = assert!(core::mem::size_of::<union_ReadErr>() == 20);
const _ALIGN_CHECK_union_ReadErr: () = assert!(core::mem::align_of::<union_ReadErr>() == 4);

const _SIZE_CHECK_ReadErr: () = assert!(core::mem::size_of::<ReadErr>() == 20);
const _ALIGN_CHECK_ReadErr: () = assert!(core::mem::align_of::<ReadErr>() == 4);

impl ReadErr {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_ReadErr {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_ReadErr>(*bytes.as_ptr().add(16))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_ReadErr) {
        let discriminant_ptr: *mut discriminant_ReadErr = (self as *mut ReadErr).cast();

        unsafe {
            *(discriminant_ptr.add(16)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct ReadErr {
    payload: union_ReadErr,
    discriminant: discriminant_ReadErr,
}

impl Clone for ReadErr {
    fn clone(&self) -> Self {
        use discriminant_ReadErr::*;

        let payload = unsafe {
            match self.discriminant {
                Interrupted => union_ReadErr {
                    Interrupted: self.payload.Interrupted.clone(),
                },
                InvalidFilename => union_ReadErr {
                    InvalidFilename: self.payload.InvalidFilename.clone(),
                },
                NotFound => union_ReadErr {
                    NotFound: self.payload.NotFound.clone(),
                },
                OutOfMemory => union_ReadErr {
                    OutOfMemory: self.payload.OutOfMemory.clone(),
                },
                PermissionDenied => union_ReadErr {
                    PermissionDenied: self.payload.PermissionDenied.clone(),
                },
                StaleNetworkFileHandle => union_ReadErr {
                    StaleNetworkFileHandle: self.payload.StaleNetworkFileHandle.clone(),
                },
                TimedOut => union_ReadErr {
                    TimedOut: self.payload.TimedOut.clone(),
                },
                TooManyHardlinks => union_ReadErr {
                    TooManyHardlinks: self.payload.TooManyHardlinks.clone(),
                },
                TooManySymlinks => union_ReadErr {
                    TooManySymlinks: self.payload.TooManySymlinks.clone(),
                },
                Unrecognized => union_ReadErr {
                    Unrecognized: self.payload.Unrecognized.clone(),
                },
                Unsupported => union_ReadErr {
                    Unsupported: self.payload.Unsupported.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for ReadErr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_ReadErr::*;

        unsafe {
            match self.discriminant {
                Interrupted => {
                    let field: &() = &self.payload.Interrupted;
                    f.debug_tuple("ReadErr::Interrupted").field(field).finish()
                },
                InvalidFilename => {
                    let field: &() = &self.payload.InvalidFilename;
                    f.debug_tuple("ReadErr::InvalidFilename").field(field).finish()
                },
                NotFound => {
                    let field: &() = &self.payload.NotFound;
                    f.debug_tuple("ReadErr::NotFound").field(field).finish()
                },
                OutOfMemory => {
                    let field: &() = &self.payload.OutOfMemory;
                    f.debug_tuple("ReadErr::OutOfMemory").field(field).finish()
                },
                PermissionDenied => {
                    let field: &() = &self.payload.PermissionDenied;
                    f.debug_tuple("ReadErr::PermissionDenied").field(field).finish()
                },
                StaleNetworkFileHandle => {
                    let field: &() = &self.payload.StaleNetworkFileHandle;
                    f.debug_tuple("ReadErr::StaleNetworkFileHandle").field(field).finish()
                },
                TimedOut => {
                    let field: &() = &self.payload.TimedOut;
                    f.debug_tuple("ReadErr::TimedOut").field(field).finish()
                },
                TooManyHardlinks => {
                    let field: &() = &self.payload.TooManyHardlinks;
                    f.debug_tuple("ReadErr::TooManyHardlinks").field(field).finish()
                },
                TooManySymlinks => {
                    let field: &() = &self.payload.TooManySymlinks;
                    f.debug_tuple("ReadErr::TooManySymlinks").field(field).finish()
                },
                Unrecognized => {
                    let field: &ReadErr_Unrecognized = &self.payload.Unrecognized;
                    f.debug_tuple("ReadErr::Unrecognized").field(field).finish()
                },
                Unsupported => {
                    let field: &() = &self.payload.Unsupported;
                    f.debug_tuple("ReadErr::Unsupported").field(field).finish()
                },
            }
        }
    }
}

impl Eq for ReadErr {}

impl PartialEq for ReadErr {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_ReadErr::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                Interrupted => self.payload.Interrupted == other.payload.Interrupted,
                InvalidFilename => self.payload.InvalidFilename == other.payload.InvalidFilename,
                NotFound => self.payload.NotFound == other.payload.NotFound,
                OutOfMemory => self.payload.OutOfMemory == other.payload.OutOfMemory,
                PermissionDenied => self.payload.PermissionDenied == other.payload.PermissionDenied,
                StaleNetworkFileHandle => self.payload.StaleNetworkFileHandle == other.payload.StaleNetworkFileHandle,
                TimedOut => self.payload.TimedOut == other.payload.TimedOut,
                TooManyHardlinks => self.payload.TooManyHardlinks == other.payload.TooManyHardlinks,
                TooManySymlinks => self.payload.TooManySymlinks == other.payload.TooManySymlinks,
                Unrecognized => self.payload.Unrecognized == other.payload.Unrecognized,
                Unsupported => self.payload.Unsupported == other.payload.Unsupported,
            }
        }
    }
}

impl Ord for ReadErr {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for ReadErr {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_ReadErr::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    Interrupted => self.payload.Interrupted.partial_cmp(&other.payload.Interrupted),
                    InvalidFilename => self.payload.InvalidFilename.partial_cmp(&other.payload.InvalidFilename),
                    NotFound => self.payload.NotFound.partial_cmp(&other.payload.NotFound),
                    OutOfMemory => self.payload.OutOfMemory.partial_cmp(&other.payload.OutOfMemory),
                    PermissionDenied => self.payload.PermissionDenied.partial_cmp(&other.payload.PermissionDenied),
                    StaleNetworkFileHandle => self.payload.StaleNetworkFileHandle.partial_cmp(&other.payload.StaleNetworkFileHandle),
                    TimedOut => self.payload.TimedOut.partial_cmp(&other.payload.TimedOut),
                    TooManyHardlinks => self.payload.TooManyHardlinks.partial_cmp(&other.payload.TooManyHardlinks),
                    TooManySymlinks => self.payload.TooManySymlinks.partial_cmp(&other.payload.TooManySymlinks),
                    Unrecognized => self.payload.Unrecognized.partial_cmp(&other.payload.Unrecognized),
                    Unsupported => self.payload.Unsupported.partial_cmp(&other.payload.Unsupported),
                }
            },
        }
    }
}

impl core::hash::Hash for ReadErr {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_ReadErr::*;

        unsafe {
            match self.discriminant {
                Interrupted => self.payload.Interrupted.hash(state),
                InvalidFilename => self.payload.InvalidFilename.hash(state),
                NotFound => self.payload.NotFound.hash(state),
                OutOfMemory => self.payload.OutOfMemory.hash(state),
                PermissionDenied => self.payload.PermissionDenied.hash(state),
                StaleNetworkFileHandle => self.payload.StaleNetworkFileHandle.hash(state),
                TimedOut => self.payload.TimedOut.hash(state),
                TooManyHardlinks => self.payload.TooManyHardlinks.hash(state),
                TooManySymlinks => self.payload.TooManySymlinks.hash(state),
                Unrecognized => self.payload.Unrecognized.hash(state),
                Unsupported => self.payload.Unsupported.hash(state),
            }
        }
    }
}

impl ReadErr {

    pub fn is_Interrupted(&self) -> bool {
        matches!(self.discriminant, discriminant_ReadErr::Interrupted)
    }

    pub fn is_InvalidFilename(&self) -> bool {
        matches!(self.discriminant, discriminant_ReadErr::InvalidFilename)
    }

    pub fn is_NotFound(&self) -> bool {
        matches!(self.discriminant, discriminant_ReadErr::NotFound)
    }

    pub fn is_OutOfMemory(&self) -> bool {
        matches!(self.discriminant, discriminant_ReadErr::OutOfMemory)
    }

    pub fn is_PermissionDenied(&self) -> bool {
        matches!(self.discriminant, discriminant_ReadErr::PermissionDenied)
    }

    pub fn is_StaleNetworkFileHandle(&self) -> bool {
        matches!(self.discriminant, discriminant_ReadErr::StaleNetworkFileHandle)
    }

    pub fn is_TimedOut(&self) -> bool {
        matches!(self.discriminant, discriminant_ReadErr::TimedOut)
    }

    pub fn is_TooManyHardlinks(&self) -> bool {
        matches!(self.discriminant, discriminant_ReadErr::TooManyHardlinks)
    }

    pub fn is_TooManySymlinks(&self) -> bool {
        matches!(self.discriminant, discriminant_ReadErr::TooManySymlinks)
    }

    pub fn unwrap_Unrecognized(mut self) -> ReadErr_Unrecognized {
        debug_assert_eq!(self.discriminant, discriminant_ReadErr::Unrecognized);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Unrecognized) }
    }

    pub fn is_Unrecognized(&self) -> bool {
        matches!(self.discriminant, discriminant_ReadErr::Unrecognized)
    }

    pub fn is_Unsupported(&self) -> bool {
        matches!(self.discriminant, discriminant_ReadErr::Unsupported)
    }
}



impl ReadErr {

    pub fn Interrupted() -> Self {
        Self {
            discriminant: discriminant_ReadErr::Interrupted,
            payload: union_ReadErr {
                Interrupted: (),
            }
        }
    }

    pub fn InvalidFilename() -> Self {
        Self {
            discriminant: discriminant_ReadErr::InvalidFilename,
            payload: union_ReadErr {
                InvalidFilename: (),
            }
        }
    }

    pub fn NotFound() -> Self {
        Self {
            discriminant: discriminant_ReadErr::NotFound,
            payload: union_ReadErr {
                NotFound: (),
            }
        }
    }

    pub fn OutOfMemory() -> Self {
        Self {
            discriminant: discriminant_ReadErr::OutOfMemory,
            payload: union_ReadErr {
                OutOfMemory: (),
            }
        }
    }

    pub fn PermissionDenied() -> Self {
        Self {
            discriminant: discriminant_ReadErr::PermissionDenied,
            payload: union_ReadErr {
                PermissionDenied: (),
            }
        }
    }

    pub fn StaleNetworkFileHandle() -> Self {
        Self {
            discriminant: discriminant_ReadErr::StaleNetworkFileHandle,
            payload: union_ReadErr {
                StaleNetworkFileHandle: (),
            }
        }
    }

    pub fn TimedOut() -> Self {
        Self {
            discriminant: discriminant_ReadErr::TimedOut,
            payload: union_ReadErr {
                TimedOut: (),
            }
        }
    }

    pub fn TooManyHardlinks() -> Self {
        Self {
            discriminant: discriminant_ReadErr::TooManyHardlinks,
            payload: union_ReadErr {
                TooManyHardlinks: (),
            }
        }
    }

    pub fn TooManySymlinks() -> Self {
        Self {
            discriminant: discriminant_ReadErr::TooManySymlinks,
            payload: union_ReadErr {
                TooManySymlinks: (),
            }
        }
    }

    pub fn Unrecognized(payload: ReadErr_Unrecognized) -> Self {
        Self {
            discriminant: discriminant_ReadErr::Unrecognized,
            payload: union_ReadErr {
                Unrecognized: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn Unsupported() -> Self {
        Self {
            discriminant: discriminant_ReadErr::Unsupported,
            payload: union_ReadErr {
                Unsupported: (),
            }
        }
    }
}

impl Drop for ReadErr {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_ReadErr::Interrupted => {}
            discriminant_ReadErr::InvalidFilename => {}
            discriminant_ReadErr::NotFound => {}
            discriminant_ReadErr::OutOfMemory => {}
            discriminant_ReadErr::PermissionDenied => {}
            discriminant_ReadErr::StaleNetworkFileHandle => {}
            discriminant_ReadErr::TimedOut => {}
            discriminant_ReadErr::TooManyHardlinks => {}
            discriminant_ReadErr::TooManySymlinks => {}
            discriminant_ReadErr::Unrecognized => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.Unrecognized) },
            discriminant_ReadErr::Unsupported => {}
        }
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_WriteErr {
    AlreadyExists = 0,
    ExecutableFileBusy = 1,
    FileTooLarge = 2,
    FilesystemQuotaExceeded = 3,
    Interrupted = 4,
    InvalidFilename = 5,
    NotFound = 6,
    OutOfMemory = 7,
    PermissionDenied = 8,
    ReadOnlyFilesystem = 9,
    ResourceBusy = 10,
    StaleNetworkFileHandle = 11,
    StorageFull = 12,
    TimedOut = 13,
    TooManyHardlinks = 14,
    TooManySymlinks = 15,
    Unrecognized = 16,
    Unsupported = 17,
    WasADirectory = 18,
    WriteZero = 19,
}

impl core::fmt::Debug for discriminant_WriteErr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::AlreadyExists => f.write_str("discriminant_WriteErr::AlreadyExists"),
            Self::ExecutableFileBusy => f.write_str("discriminant_WriteErr::ExecutableFileBusy"),
            Self::FileTooLarge => f.write_str("discriminant_WriteErr::FileTooLarge"),
            Self::FilesystemQuotaExceeded => f.write_str("discriminant_WriteErr::FilesystemQuotaExceeded"),
            Self::Interrupted => f.write_str("discriminant_WriteErr::Interrupted"),
            Self::InvalidFilename => f.write_str("discriminant_WriteErr::InvalidFilename"),
            Self::NotFound => f.write_str("discriminant_WriteErr::NotFound"),
            Self::OutOfMemory => f.write_str("discriminant_WriteErr::OutOfMemory"),
            Self::PermissionDenied => f.write_str("discriminant_WriteErr::PermissionDenied"),
            Self::ReadOnlyFilesystem => f.write_str("discriminant_WriteErr::ReadOnlyFilesystem"),
            Self::ResourceBusy => f.write_str("discriminant_WriteErr::ResourceBusy"),
            Self::StaleNetworkFileHandle => f.write_str("discriminant_WriteErr::StaleNetworkFileHandle"),
            Self::StorageFull => f.write_str("discriminant_WriteErr::StorageFull"),
            Self::TimedOut => f.write_str("discriminant_WriteErr::TimedOut"),
            Self::TooManyHardlinks => f.write_str("discriminant_WriteErr::TooManyHardlinks"),
            Self::TooManySymlinks => f.write_str("discriminant_WriteErr::TooManySymlinks"),
            Self::Unrecognized => f.write_str("discriminant_WriteErr::Unrecognized"),
            Self::Unsupported => f.write_str("discriminant_WriteErr::Unsupported"),
            Self::WasADirectory => f.write_str("discriminant_WriteErr::WasADirectory"),
            Self::WriteZero => f.write_str("discriminant_WriteErr::WriteZero"),
        }
    }
}

#[repr(C, align(4))]
pub union union_WriteErr {
    AlreadyExists: (),
    ExecutableFileBusy: (),
    FileTooLarge: (),
    FilesystemQuotaExceeded: (),
    Interrupted: (),
    InvalidFilename: (),
    NotFound: (),
    OutOfMemory: (),
    PermissionDenied: (),
    ReadOnlyFilesystem: (),
    ResourceBusy: (),
    StaleNetworkFileHandle: (),
    StorageFull: (),
    TimedOut: (),
    TooManyHardlinks: (),
    TooManySymlinks: (),
    Unrecognized: core::mem::ManuallyDrop<ReadErr_Unrecognized>,
    Unsupported: (),
    WasADirectory: (),
    WriteZero: (),
}

const _SIZE_CHECK_union_WriteErr: () = assert!(core::mem::size_of::<union_WriteErr>() == 20);
const _ALIGN_CHECK_union_WriteErr: () = assert!(core::mem::align_of::<union_WriteErr>() == 4);

const _SIZE_CHECK_WriteErr: () = assert!(core::mem::size_of::<WriteErr>() == 20);
const _ALIGN_CHECK_WriteErr: () = assert!(core::mem::align_of::<WriteErr>() == 4);

impl WriteErr {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_WriteErr {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_WriteErr>(*bytes.as_ptr().add(16))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_WriteErr) {
        let discriminant_ptr: *mut discriminant_WriteErr = (self as *mut WriteErr).cast();

        unsafe {
            *(discriminant_ptr.add(16)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct WriteErr {
    payload: union_WriteErr,
    discriminant: discriminant_WriteErr,
}

impl Clone for WriteErr {
    fn clone(&self) -> Self {
        use discriminant_WriteErr::*;

        let payload = unsafe {
            match self.discriminant {
                AlreadyExists => union_WriteErr {
                    AlreadyExists: self.payload.AlreadyExists.clone(),
                },
                ExecutableFileBusy => union_WriteErr {
                    ExecutableFileBusy: self.payload.ExecutableFileBusy.clone(),
                },
                FileTooLarge => union_WriteErr {
                    FileTooLarge: self.payload.FileTooLarge.clone(),
                },
                FilesystemQuotaExceeded => union_WriteErr {
                    FilesystemQuotaExceeded: self.payload.FilesystemQuotaExceeded.clone(),
                },
                Interrupted => union_WriteErr {
                    Interrupted: self.payload.Interrupted.clone(),
                },
                InvalidFilename => union_WriteErr {
                    InvalidFilename: self.payload.InvalidFilename.clone(),
                },
                NotFound => union_WriteErr {
                    NotFound: self.payload.NotFound.clone(),
                },
                OutOfMemory => union_WriteErr {
                    OutOfMemory: self.payload.OutOfMemory.clone(),
                },
                PermissionDenied => union_WriteErr {
                    PermissionDenied: self.payload.PermissionDenied.clone(),
                },
                ReadOnlyFilesystem => union_WriteErr {
                    ReadOnlyFilesystem: self.payload.ReadOnlyFilesystem.clone(),
                },
                ResourceBusy => union_WriteErr {
                    ResourceBusy: self.payload.ResourceBusy.clone(),
                },
                StaleNetworkFileHandle => union_WriteErr {
                    StaleNetworkFileHandle: self.payload.StaleNetworkFileHandle.clone(),
                },
                StorageFull => union_WriteErr {
                    StorageFull: self.payload.StorageFull.clone(),
                },
                TimedOut => union_WriteErr {
                    TimedOut: self.payload.TimedOut.clone(),
                },
                TooManyHardlinks => union_WriteErr {
                    TooManyHardlinks: self.payload.TooManyHardlinks.clone(),
                },
                TooManySymlinks => union_WriteErr {
                    TooManySymlinks: self.payload.TooManySymlinks.clone(),
                },
                Unrecognized => union_WriteErr {
                    Unrecognized: self.payload.Unrecognized.clone(),
                },
                Unsupported => union_WriteErr {
                    Unsupported: self.payload.Unsupported.clone(),
                },
                WasADirectory => union_WriteErr {
                    WasADirectory: self.payload.WasADirectory.clone(),
                },
                WriteZero => union_WriteErr {
                    WriteZero: self.payload.WriteZero.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for WriteErr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_WriteErr::*;

        unsafe {
            match self.discriminant {
                AlreadyExists => {
                    let field: &() = &self.payload.AlreadyExists;
                    f.debug_tuple("WriteErr::AlreadyExists").field(field).finish()
                },
                ExecutableFileBusy => {
                    let field: &() = &self.payload.ExecutableFileBusy;
                    f.debug_tuple("WriteErr::ExecutableFileBusy").field(field).finish()
                },
                FileTooLarge => {
                    let field: &() = &self.payload.FileTooLarge;
                    f.debug_tuple("WriteErr::FileTooLarge").field(field).finish()
                },
                FilesystemQuotaExceeded => {
                    let field: &() = &self.payload.FilesystemQuotaExceeded;
                    f.debug_tuple("WriteErr::FilesystemQuotaExceeded").field(field).finish()
                },
                Interrupted => {
                    let field: &() = &self.payload.Interrupted;
                    f.debug_tuple("WriteErr::Interrupted").field(field).finish()
                },
                InvalidFilename => {
                    let field: &() = &self.payload.InvalidFilename;
                    f.debug_tuple("WriteErr::InvalidFilename").field(field).finish()
                },
                NotFound => {
                    let field: &() = &self.payload.NotFound;
                    f.debug_tuple("WriteErr::NotFound").field(field).finish()
                },
                OutOfMemory => {
                    let field: &() = &self.payload.OutOfMemory;
                    f.debug_tuple("WriteErr::OutOfMemory").field(field).finish()
                },
                PermissionDenied => {
                    let field: &() = &self.payload.PermissionDenied;
                    f.debug_tuple("WriteErr::PermissionDenied").field(field).finish()
                },
                ReadOnlyFilesystem => {
                    let field: &() = &self.payload.ReadOnlyFilesystem;
                    f.debug_tuple("WriteErr::ReadOnlyFilesystem").field(field).finish()
                },
                ResourceBusy => {
                    let field: &() = &self.payload.ResourceBusy;
                    f.debug_tuple("WriteErr::ResourceBusy").field(field).finish()
                },
                StaleNetworkFileHandle => {
                    let field: &() = &self.payload.StaleNetworkFileHandle;
                    f.debug_tuple("WriteErr::StaleNetworkFileHandle").field(field).finish()
                },
                StorageFull => {
                    let field: &() = &self.payload.StorageFull;
                    f.debug_tuple("WriteErr::StorageFull").field(field).finish()
                },
                TimedOut => {
                    let field: &() = &self.payload.TimedOut;
                    f.debug_tuple("WriteErr::TimedOut").field(field).finish()
                },
                TooManyHardlinks => {
                    let field: &() = &self.payload.TooManyHardlinks;
                    f.debug_tuple("WriteErr::TooManyHardlinks").field(field).finish()
                },
                TooManySymlinks => {
                    let field: &() = &self.payload.TooManySymlinks;
                    f.debug_tuple("WriteErr::TooManySymlinks").field(field).finish()
                },
                Unrecognized => {
                    let field: &ReadErr_Unrecognized = &self.payload.Unrecognized;
                    f.debug_tuple("WriteErr::Unrecognized").field(field).finish()
                },
                Unsupported => {
                    let field: &() = &self.payload.Unsupported;
                    f.debug_tuple("WriteErr::Unsupported").field(field).finish()
                },
                WasADirectory => {
                    let field: &() = &self.payload.WasADirectory;
                    f.debug_tuple("WriteErr::WasADirectory").field(field).finish()
                },
                WriteZero => {
                    let field: &() = &self.payload.WriteZero;
                    f.debug_tuple("WriteErr::WriteZero").field(field).finish()
                },
            }
        }
    }
}

impl Eq for WriteErr {}

impl PartialEq for WriteErr {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_WriteErr::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                AlreadyExists => self.payload.AlreadyExists == other.payload.AlreadyExists,
                ExecutableFileBusy => self.payload.ExecutableFileBusy == other.payload.ExecutableFileBusy,
                FileTooLarge => self.payload.FileTooLarge == other.payload.FileTooLarge,
                FilesystemQuotaExceeded => self.payload.FilesystemQuotaExceeded == other.payload.FilesystemQuotaExceeded,
                Interrupted => self.payload.Interrupted == other.payload.Interrupted,
                InvalidFilename => self.payload.InvalidFilename == other.payload.InvalidFilename,
                NotFound => self.payload.NotFound == other.payload.NotFound,
                OutOfMemory => self.payload.OutOfMemory == other.payload.OutOfMemory,
                PermissionDenied => self.payload.PermissionDenied == other.payload.PermissionDenied,
                ReadOnlyFilesystem => self.payload.ReadOnlyFilesystem == other.payload.ReadOnlyFilesystem,
                ResourceBusy => self.payload.ResourceBusy == other.payload.ResourceBusy,
                StaleNetworkFileHandle => self.payload.StaleNetworkFileHandle == other.payload.StaleNetworkFileHandle,
                StorageFull => self.payload.StorageFull == other.payload.StorageFull,
                TimedOut => self.payload.TimedOut == other.payload.TimedOut,
                TooManyHardlinks => self.payload.TooManyHardlinks == other.payload.TooManyHardlinks,
                TooManySymlinks => self.payload.TooManySymlinks == other.payload.TooManySymlinks,
                Unrecognized => self.payload.Unrecognized == other.payload.Unrecognized,
                Unsupported => self.payload.Unsupported == other.payload.Unsupported,
                WasADirectory => self.payload.WasADirectory == other.payload.WasADirectory,
                WriteZero => self.payload.WriteZero == other.payload.WriteZero,
            }
        }
    }
}

impl Ord for WriteErr {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for WriteErr {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_WriteErr::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    AlreadyExists => self.payload.AlreadyExists.partial_cmp(&other.payload.AlreadyExists),
                    ExecutableFileBusy => self.payload.ExecutableFileBusy.partial_cmp(&other.payload.ExecutableFileBusy),
                    FileTooLarge => self.payload.FileTooLarge.partial_cmp(&other.payload.FileTooLarge),
                    FilesystemQuotaExceeded => self.payload.FilesystemQuotaExceeded.partial_cmp(&other.payload.FilesystemQuotaExceeded),
                    Interrupted => self.payload.Interrupted.partial_cmp(&other.payload.Interrupted),
                    InvalidFilename => self.payload.InvalidFilename.partial_cmp(&other.payload.InvalidFilename),
                    NotFound => self.payload.NotFound.partial_cmp(&other.payload.NotFound),
                    OutOfMemory => self.payload.OutOfMemory.partial_cmp(&other.payload.OutOfMemory),
                    PermissionDenied => self.payload.PermissionDenied.partial_cmp(&other.payload.PermissionDenied),
                    ReadOnlyFilesystem => self.payload.ReadOnlyFilesystem.partial_cmp(&other.payload.ReadOnlyFilesystem),
                    ResourceBusy => self.payload.ResourceBusy.partial_cmp(&other.payload.ResourceBusy),
                    StaleNetworkFileHandle => self.payload.StaleNetworkFileHandle.partial_cmp(&other.payload.StaleNetworkFileHandle),
                    StorageFull => self.payload.StorageFull.partial_cmp(&other.payload.StorageFull),
                    TimedOut => self.payload.TimedOut.partial_cmp(&other.payload.TimedOut),
                    TooManyHardlinks => self.payload.TooManyHardlinks.partial_cmp(&other.payload.TooManyHardlinks),
                    TooManySymlinks => self.payload.TooManySymlinks.partial_cmp(&other.payload.TooManySymlinks),
                    Unrecognized => self.payload.Unrecognized.partial_cmp(&other.payload.Unrecognized),
                    Unsupported => self.payload.Unsupported.partial_cmp(&other.payload.Unsupported),
                    WasADirectory => self.payload.WasADirectory.partial_cmp(&other.payload.WasADirectory),
                    WriteZero => self.payload.WriteZero.partial_cmp(&other.payload.WriteZero),
                }
            },
        }
    }
}

impl core::hash::Hash for WriteErr {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_WriteErr::*;

        unsafe {
            match self.discriminant {
                AlreadyExists => self.payload.AlreadyExists.hash(state),
                ExecutableFileBusy => self.payload.ExecutableFileBusy.hash(state),
                FileTooLarge => self.payload.FileTooLarge.hash(state),
                FilesystemQuotaExceeded => self.payload.FilesystemQuotaExceeded.hash(state),
                Interrupted => self.payload.Interrupted.hash(state),
                InvalidFilename => self.payload.InvalidFilename.hash(state),
                NotFound => self.payload.NotFound.hash(state),
                OutOfMemory => self.payload.OutOfMemory.hash(state),
                PermissionDenied => self.payload.PermissionDenied.hash(state),
                ReadOnlyFilesystem => self.payload.ReadOnlyFilesystem.hash(state),
                ResourceBusy => self.payload.ResourceBusy.hash(state),
                StaleNetworkFileHandle => self.payload.StaleNetworkFileHandle.hash(state),
                StorageFull => self.payload.StorageFull.hash(state),
                TimedOut => self.payload.TimedOut.hash(state),
                TooManyHardlinks => self.payload.TooManyHardlinks.hash(state),
                TooManySymlinks => self.payload.TooManySymlinks.hash(state),
                Unrecognized => self.payload.Unrecognized.hash(state),
                Unsupported => self.payload.Unsupported.hash(state),
                WasADirectory => self.payload.WasADirectory.hash(state),
                WriteZero => self.payload.WriteZero.hash(state),
            }
        }
    }
}

impl WriteErr {

    pub fn is_AlreadyExists(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::AlreadyExists)
    }

    pub fn is_ExecutableFileBusy(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::ExecutableFileBusy)
    }

    pub fn is_FileTooLarge(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::FileTooLarge)
    }

    pub fn is_FilesystemQuotaExceeded(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::FilesystemQuotaExceeded)
    }

    pub fn is_Interrupted(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::Interrupted)
    }

    pub fn is_InvalidFilename(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::InvalidFilename)
    }

    pub fn is_NotFound(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::NotFound)
    }

    pub fn is_OutOfMemory(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::OutOfMemory)
    }

    pub fn is_PermissionDenied(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::PermissionDenied)
    }

    pub fn is_ReadOnlyFilesystem(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::ReadOnlyFilesystem)
    }

    pub fn is_ResourceBusy(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::ResourceBusy)
    }

    pub fn is_StaleNetworkFileHandle(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::StaleNetworkFileHandle)
    }

    pub fn is_StorageFull(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::StorageFull)
    }

    pub fn is_TimedOut(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::TimedOut)
    }

    pub fn is_TooManyHardlinks(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::TooManyHardlinks)
    }

    pub fn is_TooManySymlinks(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::TooManySymlinks)
    }

    pub fn unwrap_Unrecognized(mut self) -> ReadErr_Unrecognized {
        debug_assert_eq!(self.discriminant, discriminant_WriteErr::Unrecognized);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Unrecognized) }
    }

    pub fn is_Unrecognized(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::Unrecognized)
    }

    pub fn is_Unsupported(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::Unsupported)
    }

    pub fn is_WasADirectory(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::WasADirectory)
    }

    pub fn is_WriteZero(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::WriteZero)
    }
}



impl WriteErr {

    pub fn AlreadyExists() -> Self {
        Self {
            discriminant: discriminant_WriteErr::AlreadyExists,
            payload: union_WriteErr {
                AlreadyExists: (),
            }
        }
    }

    pub fn ExecutableFileBusy() -> Self {
        Self {
            discriminant: discriminant_WriteErr::ExecutableFileBusy,
            payload: union_WriteErr {
                ExecutableFileBusy: (),
            }
        }
    }

    pub fn FileTooLarge() -> Self {
        Self {
            discriminant: discriminant_WriteErr::FileTooLarge,
            payload: union_WriteErr {
                FileTooLarge: (),
            }
        }
    }

    pub fn FilesystemQuotaExceeded() -> Self {
        Self {
            discriminant: discriminant_WriteErr::FilesystemQuotaExceeded,
            payload: union_WriteErr {
                FilesystemQuotaExceeded: (),
            }
        }
    }

    pub fn Interrupted() -> Self {
        Self {
            discriminant: discriminant_WriteErr::Interrupted,
            payload: union_WriteErr {
                Interrupted: (),
            }
        }
    }

    pub fn InvalidFilename() -> Self {
        Self {
            discriminant: discriminant_WriteErr::InvalidFilename,
            payload: union_WriteErr {
                InvalidFilename: (),
            }
        }
    }

    pub fn NotFound() -> Self {
        Self {
            discriminant: discriminant_WriteErr::NotFound,
            payload: union_WriteErr {
                NotFound: (),
            }
        }
    }

    pub fn OutOfMemory() -> Self {
        Self {
            discriminant: discriminant_WriteErr::OutOfMemory,
            payload: union_WriteErr {
                OutOfMemory: (),
            }
        }
    }

    pub fn PermissionDenied() -> Self {
        Self {
            discriminant: discriminant_WriteErr::PermissionDenied,
            payload: union_WriteErr {
                PermissionDenied: (),
            }
        }
    }

    pub fn ReadOnlyFilesystem() -> Self {
        Self {
            discriminant: discriminant_WriteErr::ReadOnlyFilesystem,
            payload: union_WriteErr {
                ReadOnlyFilesystem: (),
            }
        }
    }

    pub fn ResourceBusy() -> Self {
        Self {
            discriminant: discriminant_WriteErr::ResourceBusy,
            payload: union_WriteErr {
                ResourceBusy: (),
            }
        }
    }

    pub fn StaleNetworkFileHandle() -> Self {
        Self {
            discriminant: discriminant_WriteErr::StaleNetworkFileHandle,
            payload: union_WriteErr {
                StaleNetworkFileHandle: (),
            }
        }
    }

    pub fn StorageFull() -> Self {
        Self {
            discriminant: discriminant_WriteErr::StorageFull,
            payload: union_WriteErr {
                StorageFull: (),
            }
        }
    }

    pub fn TimedOut() -> Self {
        Self {
            discriminant: discriminant_WriteErr::TimedOut,
            payload: union_WriteErr {
                TimedOut: (),
            }
        }
    }

    pub fn TooManyHardlinks() -> Self {
        Self {
            discriminant: discriminant_WriteErr::TooManyHardlinks,
            payload: union_WriteErr {
                TooManyHardlinks: (),
            }
        }
    }

    pub fn TooManySymlinks() -> Self {
        Self {
            discriminant: discriminant_WriteErr::TooManySymlinks,
            payload: union_WriteErr {
                TooManySymlinks: (),
            }
        }
    }

    pub fn Unrecognized(payload: ReadErr_Unrecognized) -> Self {
        Self {
            discriminant: discriminant_WriteErr::Unrecognized,
            payload: union_WriteErr {
                Unrecognized: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn Unsupported() -> Self {
        Self {
            discriminant: discriminant_WriteErr::Unsupported,
            payload: union_WriteErr {
                Unsupported: (),
            }
        }
    }

    pub fn WasADirectory() -> Self {
        Self {
            discriminant: discriminant_WriteErr::WasADirectory,
            payload: union_WriteErr {
                WasADirectory: (),
            }
        }
    }

    pub fn WriteZero() -> Self {
        Self {
            discriminant: discriminant_WriteErr::WriteZero,
            payload: union_WriteErr {
                WriteZero: (),
            }
        }
    }
}

impl Drop for WriteErr {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_WriteErr::AlreadyExists => {}
            discriminant_WriteErr::ExecutableFileBusy => {}
            discriminant_WriteErr::FileTooLarge => {}
            discriminant_WriteErr::FilesystemQuotaExceeded => {}
            discriminant_WriteErr::Interrupted => {}
            discriminant_WriteErr::InvalidFilename => {}
            discriminant_WriteErr::NotFound => {}
            discriminant_WriteErr::OutOfMemory => {}
            discriminant_WriteErr::PermissionDenied => {}
            discriminant_WriteErr::ReadOnlyFilesystem => {}
            discriminant_WriteErr::ResourceBusy => {}
            discriminant_WriteErr::StaleNetworkFileHandle => {}
            discriminant_WriteErr::StorageFull => {}
            discriminant_WriteErr::TimedOut => {}
            discriminant_WriteErr::TooManyHardlinks => {}
            discriminant_WriteErr::TooManySymlinks => {}
            discriminant_WriteErr::Unrecognized => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.Unrecognized) },
            discriminant_WriteErr::Unsupported => {}
            discriminant_WriteErr::WasADirectory => {}
            discriminant_WriteErr::WriteZero => {}
        }
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_ConnectErr {
    AddrInUse = 0,
    AddrNotAvailable = 1,
    ConnectionRefused = 2,
    Interrupted = 3,
    PermissionDenied = 4,
    TimedOut = 5,
    Unrecognized = 6,
    Unsupported = 7,
}

impl core::fmt::Debug for discriminant_ConnectErr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::AddrInUse => f.write_str("discriminant_ConnectErr::AddrInUse"),
            Self::AddrNotAvailable => f.write_str("discriminant_ConnectErr::AddrNotAvailable"),
            Self::ConnectionRefused => f.write_str("discriminant_ConnectErr::ConnectionRefused"),
            Self::Interrupted => f.write_str("discriminant_ConnectErr::Interrupted"),
            Self::PermissionDenied => f.write_str("discriminant_ConnectErr::PermissionDenied"),
            Self::TimedOut => f.write_str("discriminant_ConnectErr::TimedOut"),
            Self::Unrecognized => f.write_str("discriminant_ConnectErr::Unrecognized"),
            Self::Unsupported => f.write_str("discriminant_ConnectErr::Unsupported"),
        }
    }
}

#[repr(C, align(4))]
pub union union_ConnectErr {
    AddrInUse: (),
    AddrNotAvailable: (),
    ConnectionRefused: (),
    Interrupted: (),
    PermissionDenied: (),
    TimedOut: (),
    Unrecognized: core::mem::ManuallyDrop<ReadErr_Unrecognized>,
    Unsupported: (),
}

const _SIZE_CHECK_union_ConnectErr: () = assert!(core::mem::size_of::<union_ConnectErr>() == 20);
const _ALIGN_CHECK_union_ConnectErr: () = assert!(core::mem::align_of::<union_ConnectErr>() == 4);

const _SIZE_CHECK_ConnectErr: () = assert!(core::mem::size_of::<ConnectErr>() == 20);
const _ALIGN_CHECK_ConnectErr: () = assert!(core::mem::align_of::<ConnectErr>() == 4);

impl ConnectErr {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_ConnectErr {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_ConnectErr>(*bytes.as_ptr().add(16))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_ConnectErr) {
        let discriminant_ptr: *mut discriminant_ConnectErr = (self as *mut ConnectErr).cast();

        unsafe {
            *(discriminant_ptr.add(16)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct ConnectErr {
    payload: union_ConnectErr,
    discriminant: discriminant_ConnectErr,
}

impl Clone for ConnectErr {
    fn clone(&self) -> Self {
        use discriminant_ConnectErr::*;

        let payload = unsafe {
            match self.discriminant {
                AddrInUse => union_ConnectErr {
                    AddrInUse: self.payload.AddrInUse.clone(),
                },
                AddrNotAvailable => union_ConnectErr {
                    AddrNotAvailable: self.payload.AddrNotAvailable.clone(),
                },
                ConnectionRefused => union_ConnectErr {
                    ConnectionRefused: self.payload.ConnectionRefused.clone(),
                },
                Interrupted => union_ConnectErr {
                    Interrupted: self.payload.Interrupted.clone(),
                },
                PermissionDenied => union_ConnectErr {
                    PermissionDenied: self.payload.PermissionDenied.clone(),
                },
                TimedOut => union_ConnectErr {
                    TimedOut: self.payload.TimedOut.clone(),
                },
                Unrecognized => union_ConnectErr {
                    Unrecognized: self.payload.Unrecognized.clone(),
                },
                Unsupported => union_ConnectErr {
                    Unsupported: self.payload.Unsupported.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for ConnectErr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_ConnectErr::*;

        unsafe {
            match self.discriminant {
                AddrInUse => {
                    let field: &() = &self.payload.AddrInUse;
                    f.debug_tuple("ConnectErr::AddrInUse").field(field).finish()
                },
                AddrNotAvailable => {
                    let field: &() = &self.payload.AddrNotAvailable;
                    f.debug_tuple("ConnectErr::AddrNotAvailable").field(field).finish()
                },
                ConnectionRefused => {
                    let field: &() = &self.payload.ConnectionRefused;
                    f.debug_tuple("ConnectErr::ConnectionRefused").field(field).finish()
                },
                Interrupted => {
                    let field: &() = &self.payload.Interrupted;
                    f.debug_tuple("ConnectErr::Interrupted").field(field).finish()
                },
                PermissionDenied => {
                    let field: &() = &self.payload.PermissionDenied;
                    f.debug_tuple("ConnectErr::PermissionDenied").field(field).finish()
                },
                TimedOut => {
                    let field: &() = &self.payload.TimedOut;
                    f.debug_tuple("ConnectErr::TimedOut").field(field).finish()
                },
                Unrecognized => {
                    let field: &ReadErr_Unrecognized = &self.payload.Unrecognized;
                    f.debug_tuple("ConnectErr::Unrecognized").field(field).finish()
                },
                Unsupported => {
                    let field: &() = &self.payload.Unsupported;
                    f.debug_tuple("ConnectErr::Unsupported").field(field).finish()
                },
            }
        }
    }
}

impl Eq for ConnectErr {}

impl PartialEq for ConnectErr {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_ConnectErr::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                AddrInUse => self.payload.AddrInUse == other.payload.AddrInUse,
                AddrNotAvailable => self.payload.AddrNotAvailable == other.payload.AddrNotAvailable,
                ConnectionRefused => self.payload.ConnectionRefused == other.payload.ConnectionRefused,
                Interrupted => self.payload.Interrupted == other.payload.Interrupted,
                PermissionDenied => self.payload.PermissionDenied == other.payload.PermissionDenied,
                TimedOut => self.payload.TimedOut == other.payload.TimedOut,
                Unrecognized => self.payload.Unrecognized == other.payload.Unrecognized,
                Unsupported => self.payload.Unsupported == other.payload.Unsupported,
            }
        }
    }
}

impl Ord for ConnectErr {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for ConnectErr {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_ConnectErr::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    AddrInUse => self.payload.AddrInUse.partial_cmp(&other.payload.AddrInUse),
                    AddrNotAvailable => self.payload.AddrNotAvailable.partial_cmp(&other.payload.AddrNotAvailable),
                    ConnectionRefused => self.payload.ConnectionRefused.partial_cmp(&other.payload.ConnectionRefused),
                    Interrupted => self.payload.Interrupted.partial_cmp(&other.payload.Interrupted),
                    PermissionDenied => self.payload.PermissionDenied.partial_cmp(&other.payload.PermissionDenied),
                    TimedOut => self.payload.TimedOut.partial_cmp(&other.payload.TimedOut),
                    Unrecognized => self.payload.Unrecognized.partial_cmp(&other.payload.Unrecognized),
                    Unsupported => self.payload.Unsupported.partial_cmp(&other.payload.Unsupported),
                }
            },
        }
    }
}

impl core::hash::Hash for ConnectErr {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_ConnectErr::*;

        unsafe {
            match self.discriminant {
                AddrInUse => self.payload.AddrInUse.hash(state),
                AddrNotAvailable => self.payload.AddrNotAvailable.hash(state),
                ConnectionRefused => self.payload.ConnectionRefused.hash(state),
                Interrupted => self.payload.Interrupted.hash(state),
                PermissionDenied => self.payload.PermissionDenied.hash(state),
                TimedOut => self.payload.TimedOut.hash(state),
                Unrecognized => self.payload.Unrecognized.hash(state),
                Unsupported => self.payload.Unsupported.hash(state),
            }
        }
    }
}

impl ConnectErr {

    pub fn is_AddrInUse(&self) -> bool {
        matches!(self.discriminant, discriminant_ConnectErr::AddrInUse)
    }

    pub fn is_AddrNotAvailable(&self) -> bool {
        matches!(self.discriminant, discriminant_ConnectErr::AddrNotAvailable)
    }

    pub fn is_ConnectionRefused(&self) -> bool {
        matches!(self.discriminant, discriminant_ConnectErr::ConnectionRefused)
    }

    pub fn is_Interrupted(&self) -> bool {
        matches!(self.discriminant, discriminant_ConnectErr::Interrupted)
    }

    pub fn is_PermissionDenied(&self) -> bool {
        matches!(self.discriminant, discriminant_ConnectErr::PermissionDenied)
    }

    pub fn is_TimedOut(&self) -> bool {
        matches!(self.discriminant, discriminant_ConnectErr::TimedOut)
    }

    pub fn unwrap_Unrecognized(mut self) -> ReadErr_Unrecognized {
        debug_assert_eq!(self.discriminant, discriminant_ConnectErr::Unrecognized);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Unrecognized) }
    }

    pub fn is_Unrecognized(&self) -> bool {
        matches!(self.discriminant, discriminant_ConnectErr::Unrecognized)
    }

    pub fn is_Unsupported(&self) -> bool {
        matches!(self.discriminant, discriminant_ConnectErr::Unsupported)
    }
}



impl ConnectErr {

    pub fn AddrInUse() -> Self {
        Self {
            discriminant: discriminant_ConnectErr::AddrInUse,
            payload: union_ConnectErr {
                AddrInUse: (),
            }
        }
    }

    pub fn AddrNotAvailable() -> Self {
        Self {
            discriminant: discriminant_ConnectErr::AddrNotAvailable,
            payload: union_ConnectErr {
                AddrNotAvailable: (),
            }
        }
    }

    pub fn ConnectionRefused() -> Self {
        Self {
            discriminant: discriminant_ConnectErr::ConnectionRefused,
            payload: union_ConnectErr {
                ConnectionRefused: (),
            }
        }
    }

    pub fn Interrupted() -> Self {
        Self {
            discriminant: discriminant_ConnectErr::Interrupted,
            payload: union_ConnectErr {
                Interrupted: (),
            }
        }
    }

    pub fn PermissionDenied() -> Self {
        Self {
            discriminant: discriminant_ConnectErr::PermissionDenied,
            payload: union_ConnectErr {
                PermissionDenied: (),
            }
        }
    }

    pub fn TimedOut() -> Self {
        Self {
            discriminant: discriminant_ConnectErr::TimedOut,
            payload: union_ConnectErr {
                TimedOut: (),
            }
        }
    }

    pub fn Unrecognized(payload: ReadErr_Unrecognized) -> Self {
        Self {
            discriminant: discriminant_ConnectErr::Unrecognized,
            payload: union_ConnectErr {
                Unrecognized: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn Unsupported() -> Self {
        Self {
            discriminant: discriminant_ConnectErr::Unsupported,
            payload: union_ConnectErr {
                Unsupported: (),
            }
        }
    }
}

impl Drop for ConnectErr {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_ConnectErr::AddrInUse => {}
            discriminant_ConnectErr::AddrNotAvailable => {}
            discriminant_ConnectErr::ConnectionRefused => {}
            discriminant_ConnectErr::Interrupted => {}
            discriminant_ConnectErr::PermissionDenied => {}
            discriminant_ConnectErr::TimedOut => {}
            discriminant_ConnectErr::Unrecognized => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.Unrecognized) },
            discriminant_ConnectErr::Unsupported => {}
        }
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_StreamErr {
    BrokenPipe = 0,
    ConnectionRefused = 1,
    ConnectionReset = 2,
    Interrupted = 3,
    OutOfMemory = 4,
    PermissionDenied = 5,
    Unrecognized = 6,
}

impl core::fmt::Debug for discriminant_StreamErr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::BrokenPipe => f.write_str("discriminant_StreamErr::BrokenPipe"),
            Self::ConnectionRefused => f.write_str("discriminant_StreamErr::ConnectionRefused"),
            Self::ConnectionReset => f.write_str("discriminant_StreamErr::ConnectionReset"),
            Self::Interrupted => f.write_str("discriminant_StreamErr::Interrupted"),
            Self::OutOfMemory => f.write_str("discriminant_StreamErr::OutOfMemory"),
            Self::PermissionDenied => f.write_str("discriminant_StreamErr::PermissionDenied"),
            Self::Unrecognized => f.write_str("discriminant_StreamErr::Unrecognized"),
        }
    }
}

#[repr(C, align(4))]
pub union union_StreamErr {
    BrokenPipe: (),
    ConnectionRefused: (),
    ConnectionReset: (),
    Interrupted: (),
    OutOfMemory: (),
    PermissionDenied: (),
    Unrecognized: core::mem::ManuallyDrop<ReadErr_Unrecognized>,
}

const _SIZE_CHECK_union_StreamErr: () = assert!(core::mem::size_of::<union_StreamErr>() == 20);
const _ALIGN_CHECK_union_StreamErr: () = assert!(core::mem::align_of::<union_StreamErr>() == 4);

const _SIZE_CHECK_StreamErr: () = assert!(core::mem::size_of::<StreamErr>() == 20);
const _ALIGN_CHECK_StreamErr: () = assert!(core::mem::align_of::<StreamErr>() == 4);

impl StreamErr {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_StreamErr {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_StreamErr>(*bytes.as_ptr().add(16))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_StreamErr) {
        let discriminant_ptr: *mut discriminant_StreamErr = (self as *mut StreamErr).cast();

        unsafe {
            *(discriminant_ptr.add(16)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct StreamErr {
    payload: union_StreamErr,
    discriminant: discriminant_StreamErr,
}

impl Clone for StreamErr {
    fn clone(&self) -> Self {
        use discriminant_StreamErr::*;

        let payload = unsafe {
            match self.discriminant {
                BrokenPipe => union_StreamErr {
                    BrokenPipe: self.payload.BrokenPipe.clone(),
                },
                ConnectionRefused => union_StreamErr {
                    ConnectionRefused: self.payload.ConnectionRefused.clone(),
                },
                ConnectionReset => union_StreamErr {
                    ConnectionReset: self.payload.ConnectionReset.clone(),
                },
                Interrupted => union_StreamErr {
                    Interrupted: self.payload.Interrupted.clone(),
                },
                OutOfMemory => union_StreamErr {
                    OutOfMemory: self.payload.OutOfMemory.clone(),
                },
                PermissionDenied => union_StreamErr {
                    PermissionDenied: self.payload.PermissionDenied.clone(),
                },
                Unrecognized => union_StreamErr {
                    Unrecognized: self.payload.Unrecognized.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for StreamErr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_StreamErr::*;

        unsafe {
            match self.discriminant {
                BrokenPipe => {
                    let field: &() = &self.payload.BrokenPipe;
                    f.debug_tuple("StreamErr::BrokenPipe").field(field).finish()
                },
                ConnectionRefused => {
                    let field: &() = &self.payload.ConnectionRefused;
                    f.debug_tuple("StreamErr::ConnectionRefused").field(field).finish()
                },
                ConnectionReset => {
                    let field: &() = &self.payload.ConnectionReset;
                    f.debug_tuple("StreamErr::ConnectionReset").field(field).finish()
                },
                Interrupted => {
                    let field: &() = &self.payload.Interrupted;
                    f.debug_tuple("StreamErr::Interrupted").field(field).finish()
                },
                OutOfMemory => {
                    let field: &() = &self.payload.OutOfMemory;
                    f.debug_tuple("StreamErr::OutOfMemory").field(field).finish()
                },
                PermissionDenied => {
                    let field: &() = &self.payload.PermissionDenied;
                    f.debug_tuple("StreamErr::PermissionDenied").field(field).finish()
                },
                Unrecognized => {
                    let field: &ReadErr_Unrecognized = &self.payload.Unrecognized;
                    f.debug_tuple("StreamErr::Unrecognized").field(field).finish()
                },
            }
        }
    }
}

impl Eq for StreamErr {}

impl PartialEq for StreamErr {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_StreamErr::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                BrokenPipe => self.payload.BrokenPipe == other.payload.BrokenPipe,
                ConnectionRefused => self.payload.ConnectionRefused == other.payload.ConnectionRefused,
                ConnectionReset => self.payload.ConnectionReset == other.payload.ConnectionReset,
                Interrupted => self.payload.Interrupted == other.payload.Interrupted,
                OutOfMemory => self.payload.OutOfMemory == other.payload.OutOfMemory,
                PermissionDenied => self.payload.PermissionDenied == other.payload.PermissionDenied,
                Unrecognized => self.payload.Unrecognized == other.payload.Unrecognized,
            }
        }
    }
}

impl Ord for StreamErr {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for StreamErr {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_StreamErr::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    BrokenPipe => self.payload.BrokenPipe.partial_cmp(&other.payload.BrokenPipe),
                    ConnectionRefused => self.payload.ConnectionRefused.partial_cmp(&other.payload.ConnectionRefused),
                    ConnectionReset => self.payload.ConnectionReset.partial_cmp(&other.payload.ConnectionReset),
                    Interrupted => self.payload.Interrupted.partial_cmp(&other.payload.Interrupted),
                    OutOfMemory => self.payload.OutOfMemory.partial_cmp(&other.payload.OutOfMemory),
                    PermissionDenied => self.payload.PermissionDenied.partial_cmp(&other.payload.PermissionDenied),
                    Unrecognized => self.payload.Unrecognized.partial_cmp(&other.payload.Unrecognized),
                }
            },
        }
    }
}

impl core::hash::Hash for StreamErr {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_StreamErr::*;

        unsafe {
            match self.discriminant {
                BrokenPipe => self.payload.BrokenPipe.hash(state),
                ConnectionRefused => self.payload.ConnectionRefused.hash(state),
                ConnectionReset => self.payload.ConnectionReset.hash(state),
                Interrupted => self.payload.Interrupted.hash(state),
                OutOfMemory => self.payload.OutOfMemory.hash(state),
                PermissionDenied => self.payload.PermissionDenied.hash(state),
                Unrecognized => self.payload.Unrecognized.hash(state),
            }
        }
    }
}

impl StreamErr {

    pub fn is_BrokenPipe(&self) -> bool {
        matches!(self.discriminant, discriminant_StreamErr::BrokenPipe)
    }

    pub fn is_ConnectionRefused(&self) -> bool {
        matches!(self.discriminant, discriminant_StreamErr::ConnectionRefused)
    }

    pub fn is_ConnectionReset(&self) -> bool {
        matches!(self.discriminant, discriminant_StreamErr::ConnectionReset)
    }

    pub fn is_Interrupted(&self) -> bool {
        matches!(self.discriminant, discriminant_StreamErr::Interrupted)
    }

    pub fn is_OutOfMemory(&self) -> bool {
        matches!(self.discriminant, discriminant_StreamErr::OutOfMemory)
    }

    pub fn is_PermissionDenied(&self) -> bool {
        matches!(self.discriminant, discriminant_StreamErr::PermissionDenied)
    }

    pub fn unwrap_Unrecognized(mut self) -> ReadErr_Unrecognized {
        debug_assert_eq!(self.discriminant, discriminant_StreamErr::Unrecognized);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Unrecognized) }
    }

    pub fn is_Unrecognized(&self) -> bool {
        matches!(self.discriminant, discriminant_StreamErr::Unrecognized)
    }
}



impl StreamErr {

    pub fn BrokenPipe() -> Self {
        Self {
            discriminant: discriminant_StreamErr::BrokenPipe,
            payload: union_StreamErr {
                BrokenPipe: (),
            }
        }
    }

    pub fn ConnectionRefused() -> Self {
        Self {
            discriminant: discriminant_StreamErr::ConnectionRefused,
            payload: union_StreamErr {
                ConnectionRefused: (),
            }
        }
    }

    pub fn ConnectionReset() -> Self {
        Self {
            discriminant: discriminant_StreamErr::ConnectionReset,
            payload: union_StreamErr {
                ConnectionReset: (),
            }
        }
    }

    pub fn Interrupted() -> Self {
        Self {
            discriminant: discriminant_StreamErr::Interrupted,
            payload: union_StreamErr {
                Interrupted: (),
            }
        }
    }

    pub fn OutOfMemory() -> Self {
        Self {
            discriminant: discriminant_StreamErr::OutOfMemory,
            payload: union_StreamErr {
                OutOfMemory: (),
            }
        }
    }

    pub fn PermissionDenied() -> Self {
        Self {
            discriminant: discriminant_StreamErr::PermissionDenied,
            payload: union_StreamErr {
                PermissionDenied: (),
            }
        }
    }

    pub fn Unrecognized(payload: ReadErr_Unrecognized) -> Self {
        Self {
            discriminant: discriminant_StreamErr::Unrecognized,
            payload: union_StreamErr {
                Unrecognized: core::mem::ManuallyDrop::new(payload),
            }
        }
    }
}

impl Drop for StreamErr {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_StreamErr::BrokenPipe => {}
            discriminant_StreamErr::ConnectionRefused => {}
            discriminant_StreamErr::ConnectionReset => {}
            discriminant_StreamErr::Interrupted => {}
            discriminant_StreamErr::OutOfMemory => {}
            discriminant_StreamErr::PermissionDenied => {}
            discriminant_StreamErr::Unrecognized => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.Unrecognized) },
        }
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_ConnectResult {
    Connected = 0,
    Error = 1,
}

impl core::fmt::Debug for discriminant_ConnectResult {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Connected => f.write_str("discriminant_ConnectResult::Connected"),
            Self::Error => f.write_str("discriminant_ConnectResult::Error"),
        }
    }
}

#[repr(C, align(4))]
pub union union_ConnectResult {
    Connected: u32,
    Error: core::mem::ManuallyDrop<ConnectErr>,
}

const _SIZE_CHECK_union_ConnectResult: () = assert!(core::mem::size_of::<union_ConnectResult>() == 20);
const _ALIGN_CHECK_union_ConnectResult: () = assert!(core::mem::align_of::<union_ConnectResult>() == 4);

const _SIZE_CHECK_ConnectResult: () = assert!(core::mem::size_of::<ConnectResult>() == 24);
const _ALIGN_CHECK_ConnectResult: () = assert!(core::mem::align_of::<ConnectResult>() == 4);

impl ConnectResult {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_ConnectResult {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_ConnectResult>(*bytes.as_ptr().add(20))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_ConnectResult) {
        let discriminant_ptr: *mut discriminant_ConnectResult = (self as *mut ConnectResult).cast();

        unsafe {
            *(discriminant_ptr.add(20)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct ConnectResult {
    payload: union_ConnectResult,
    discriminant: discriminant_ConnectResult,
}

impl Clone for ConnectResult {
    fn clone(&self) -> Self {
        use discriminant_ConnectResult::*;

        let payload = unsafe {
            match self.discriminant {
                Connected => union_ConnectResult {
                    Connected: self.payload.Connected.clone(),
                },
                Error => union_ConnectResult {
                    Error: self.payload.Error.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for ConnectResult {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_ConnectResult::*;

        unsafe {
            match self.discriminant {
                Connected => {
                    let field: &u32 = &self.payload.Connected;
                    f.debug_tuple("ConnectResult::Connected").field(field).finish()
                },
                Error => {
                    let field: &ConnectErr = &self.payload.Error;
                    f.debug_tuple("ConnectResult::Error").field(field).finish()
                },
            }
        }
    }
}

impl Eq for ConnectResult {}

impl PartialEq for ConnectResult {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_ConnectResult::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                Connected => self.payload.Connected == other.payload.Connected,
                Error => self.payload.Error == other.payload.Error,
            }
        }
    }
}

impl Ord for ConnectResult {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for ConnectResult {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_ConnectResult::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    Connected => self.payload.Connected.partial_cmp(&other.payload.Connected),
                    Error => self.payload.Error.partial_cmp(&other.payload.Error),
                }
            },
        }
    }
}

impl core::hash::Hash for ConnectResult {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_ConnectResult::*;

        unsafe {
            match self.discriminant {
                Connected => self.payload.Connected.hash(state),
                Error => self.payload.Error.hash(state),
            }
        }
    }
}

impl ConnectResult {

    pub fn unwrap_Connected(mut self) -> u32 {
        debug_assert_eq!(self.discriminant, discriminant_ConnectResult::Connected);
        unsafe { self.payload.Connected }
    }

    pub fn is_Connected(&self) -> bool {
        matches!(self.discriminant, discriminant_ConnectResult::Connected)
    }

    pub fn unwrap_Error(mut self) -> ConnectErr {
        debug_assert_eq!(self.discriminant, discriminant_ConnectResult::Error);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Error) }
    }

    pub fn is_Error(&self) -> bool {
        matches!(self.discriminant, discriminant_ConnectResult::Error)
    }
}



impl ConnectResult {

    pub fn Connected(payload: u32) -> Self {
        Self {
            discriminant: discriminant_ConnectResult::Connected,
            payload: union_ConnectResult {
                Connected: payload,
            }
        }
    }

    pub fn Error(payload: ConnectErr) -> Self {
        Self {
            discriminant: discriminant_ConnectResult::Error,
            payload: union_ConnectResult {
                Error: core::mem::ManuallyDrop::new(payload),
            }
        }
    }
}

impl Drop for ConnectResult {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_ConnectResult::Connected => {}
            discriminant_ConnectResult::Error => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.Error) },
        }
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_WriteResult {
    Error = 0,
    Wrote = 1,
}

impl core::fmt::Debug for discriminant_WriteResult {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Error => f.write_str("discriminant_WriteResult::Error"),
            Self::Wrote => f.write_str("discriminant_WriteResult::Wrote"),
        }
    }
}

#[repr(C, align(4))]
pub union union_WriteResult {
    Error: core::mem::ManuallyDrop<StreamErr>,
    Wrote: (),
}

const _SIZE_CHECK_union_WriteResult: () = assert!(core::mem::size_of::<union_WriteResult>() == 20);
const _ALIGN_CHECK_union_WriteResult: () = assert!(core::mem::align_of::<union_WriteResult>() == 4);

const _SIZE_CHECK_WriteResult: () = assert!(core::mem::size_of::<WriteResult>() == 24);
const _ALIGN_CHECK_WriteResult: () = assert!(core::mem::align_of::<WriteResult>() == 4);

impl WriteResult {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_WriteResult {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_WriteResult>(*bytes.as_ptr().add(20))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_WriteResult) {
        let discriminant_ptr: *mut discriminant_WriteResult = (self as *mut WriteResult).cast();

        unsafe {
            *(discriminant_ptr.add(20)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct WriteResult {
    payload: union_WriteResult,
    discriminant: discriminant_WriteResult,
}

impl Clone for WriteResult {
    fn clone(&self) -> Self {
        use discriminant_WriteResult::*;

        let payload = unsafe {
            match self.discriminant {
                Error => union_WriteResult {
                    Error: self.payload.Error.clone(),
                },
                Wrote => union_WriteResult {
                    Wrote: self.payload.Wrote.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for WriteResult {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_WriteResult::*;

        unsafe {
            match self.discriminant {
                Error => {
                    let field: &StreamErr = &self.payload.Error;
                    f.debug_tuple("WriteResult::Error").field(field).finish()
                },
                Wrote => {
                    let field: &() = &self.payload.Wrote;
                    f.debug_tuple("WriteResult::Wrote").field(field).finish()
                },
            }
        }
    }
}

impl Eq for WriteResult {}

impl PartialEq for WriteResult {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_WriteResult::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                Error => self.payload.Error == other.payload.Error,
                Wrote => self.payload.Wrote == other.payload.Wrote,
            }
        }
    }
}

impl Ord for WriteResult {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for WriteResult {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_WriteResult::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    Error => self.payload.Error.partial_cmp(&other.payload.Error),
                    Wrote => self.payload.Wrote.partial_cmp(&other.payload.Wrote),
                }
            },
        }
    }
}

impl core::hash::Hash for WriteResult {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_WriteResult::*;

        unsafe {
            match self.discriminant {
                Error => self.payload.Error.hash(state),
                Wrote => self.payload.Wrote.hash(state),
            }
        }
    }
}

impl WriteResult {

    pub fn unwrap_Error(mut self) -> StreamErr {
        debug_assert_eq!(self.discriminant, discriminant_WriteResult::Error);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Error) }
    }

    pub fn is_Error(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteResult::Error)
    }

    pub fn is_Wrote(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteResult::Wrote)
    }
}



impl WriteResult {

    pub fn Error(payload: StreamErr) -> Self {
        Self {
            discriminant: discriminant_WriteResult::Error,
            payload: union_WriteResult {
                Error: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn Wrote() -> Self {
        Self {
            discriminant: discriminant_WriteResult::Wrote,
            payload: union_WriteResult {
                Wrote: (),
            }
        }
    }
}

impl Drop for WriteResult {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_WriteResult::Error => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.Error) },
            discriminant_WriteResult::Wrote => {}
        }
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_ReadResult {
    Error = 0,
    Read = 1,
}

impl core::fmt::Debug for discriminant_ReadResult {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Error => f.write_str("discriminant_ReadResult::Error"),
            Self::Read => f.write_str("discriminant_ReadResult::Read"),
        }
    }
}

#[repr(C, align(4))]
pub union union_ReadResult {
    Error: core::mem::ManuallyDrop<StreamErr>,
    Read: core::mem::ManuallyDrop<roc_std::RocList<u8>>,
}

const _SIZE_CHECK_union_ReadResult: () = assert!(core::mem::size_of::<union_ReadResult>() == 20);
const _ALIGN_CHECK_union_ReadResult: () = assert!(core::mem::align_of::<union_ReadResult>() == 4);

const _SIZE_CHECK_ReadResult: () = assert!(core::mem::size_of::<ReadResult>() == 24);
const _ALIGN_CHECK_ReadResult: () = assert!(core::mem::align_of::<ReadResult>() == 4);

impl ReadResult {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_ReadResult {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_ReadResult>(*bytes.as_ptr().add(20))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_ReadResult) {
        let discriminant_ptr: *mut discriminant_ReadResult = (self as *mut ReadResult).cast();

        unsafe {
            *(discriminant_ptr.add(20)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct ReadResult {
    payload: union_ReadResult,
    discriminant: discriminant_ReadResult,
}

impl Clone for ReadResult {
    fn clone(&self) -> Self {
        use discriminant_ReadResult::*;

        let payload = unsafe {
            match self.discriminant {
                Error => union_ReadResult {
                    Error: self.payload.Error.clone(),
                },
                Read => union_ReadResult {
                    Read: self.payload.Read.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for ReadResult {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_ReadResult::*;

        unsafe {
            match self.discriminant {
                Error => {
                    let field: &StreamErr = &self.payload.Error;
                    f.debug_tuple("ReadResult::Error").field(field).finish()
                },
                Read => {
                    let field: &roc_std::RocList<u8> = &self.payload.Read;
                    f.debug_tuple("ReadResult::Read").field(field).finish()
                },
            }
        }
    }
}

impl Eq for ReadResult {}

impl PartialEq for ReadResult {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_ReadResult::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                Error => self.payload.Error == other.payload.Error,
                Read => self.payload.Read == other.payload.Read,
            }
        }
    }
}

impl Ord for ReadResult {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for ReadResult {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_ReadResult::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    Error => self.payload.Error.partial_cmp(&other.payload.Error),
                    Read => self.payload.Read.partial_cmp(&other.payload.Read),
                }
            },
        }
    }
}

impl core::hash::Hash for ReadResult {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_ReadResult::*;

        unsafe {
            match self.discriminant {
                Error => self.payload.Error.hash(state),
                Read => self.payload.Read.hash(state),
            }
        }
    }
}

impl ReadResult {

    pub fn unwrap_Error(mut self) -> StreamErr {
        debug_assert_eq!(self.discriminant, discriminant_ReadResult::Error);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Error) }
    }

    pub fn is_Error(&self) -> bool {
        matches!(self.discriminant, discriminant_ReadResult::Error)
    }

    pub fn unwrap_Read(mut self) -> roc_std::RocList<u8> {
        debug_assert_eq!(self.discriminant, discriminant_ReadResult::Read);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Read) }
    }

    pub fn is_Read(&self) -> bool {
        matches!(self.discriminant, discriminant_ReadResult::Read)
    }
}



impl ReadResult {

    pub fn Error(payload: StreamErr) -> Self {
        Self {
            discriminant: discriminant_ReadResult::Error,
            payload: union_ReadResult {
                Error: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn Read(payload: roc_std::RocList<u8>) -> Self {
        Self {
            discriminant: discriminant_ReadResult::Read,
            payload: union_ReadResult {
                Read: core::mem::ManuallyDrop::new(payload),
            }
        }
    }
}

impl Drop for ReadResult {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_ReadResult::Error => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.Error) },
            discriminant_ReadResult::Read => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.Read) },
        }
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_ReadExactlyResult {
    Error = 0,
    Read = 1,
    UnexpectedEOF = 2,
}

impl core::fmt::Debug for discriminant_ReadExactlyResult {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Error => f.write_str("discriminant_ReadExactlyResult::Error"),
            Self::Read => f.write_str("discriminant_ReadExactlyResult::Read"),
            Self::UnexpectedEOF => f.write_str("discriminant_ReadExactlyResult::UnexpectedEOF"),
        }
    }
}

#[repr(C, align(4))]
pub union union_ReadExactlyResult {
    Error: core::mem::ManuallyDrop<StreamErr>,
    Read: core::mem::ManuallyDrop<roc_std::RocList<u8>>,
    UnexpectedEOF: (),
}

const _SIZE_CHECK_union_ReadExactlyResult: () = assert!(core::mem::size_of::<union_ReadExactlyResult>() == 20);
const _ALIGN_CHECK_union_ReadExactlyResult: () = assert!(core::mem::align_of::<union_ReadExactlyResult>() == 4);

const _SIZE_CHECK_ReadExactlyResult: () = assert!(core::mem::size_of::<ReadExactlyResult>() == 24);
const _ALIGN_CHECK_ReadExactlyResult: () = assert!(core::mem::align_of::<ReadExactlyResult>() == 4);

impl ReadExactlyResult {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_ReadExactlyResult {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_ReadExactlyResult>(*bytes.as_ptr().add(20))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_ReadExactlyResult) {
        let discriminant_ptr: *mut discriminant_ReadExactlyResult = (self as *mut ReadExactlyResult).cast();

        unsafe {
            *(discriminant_ptr.add(20)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct ReadExactlyResult {
    payload: union_ReadExactlyResult,
    discriminant: discriminant_ReadExactlyResult,
}

impl Clone for ReadExactlyResult {
    fn clone(&self) -> Self {
        use discriminant_ReadExactlyResult::*;

        let payload = unsafe {
            match self.discriminant {
                Error => union_ReadExactlyResult {
                    Error: self.payload.Error.clone(),
                },
                Read => union_ReadExactlyResult {
                    Read: self.payload.Read.clone(),
                },
                UnexpectedEOF => union_ReadExactlyResult {
                    UnexpectedEOF: self.payload.UnexpectedEOF.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for ReadExactlyResult {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_ReadExactlyResult::*;

        unsafe {
            match self.discriminant {
                Error => {
                    let field: &StreamErr = &self.payload.Error;
                    f.debug_tuple("ReadExactlyResult::Error").field(field).finish()
                },
                Read => {
                    let field: &roc_std::RocList<u8> = &self.payload.Read;
                    f.debug_tuple("ReadExactlyResult::Read").field(field).finish()
                },
                UnexpectedEOF => {
                    let field: &() = &self.payload.UnexpectedEOF;
                    f.debug_tuple("ReadExactlyResult::UnexpectedEOF").field(field).finish()
                },
            }
        }
    }
}

impl Eq for ReadExactlyResult {}

impl PartialEq for ReadExactlyResult {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_ReadExactlyResult::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                Error => self.payload.Error == other.payload.Error,
                Read => self.payload.Read == other.payload.Read,
                UnexpectedEOF => self.payload.UnexpectedEOF == other.payload.UnexpectedEOF,
            }
        }
    }
}

impl Ord for ReadExactlyResult {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for ReadExactlyResult {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_ReadExactlyResult::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    Error => self.payload.Error.partial_cmp(&other.payload.Error),
                    Read => self.payload.Read.partial_cmp(&other.payload.Read),
                    UnexpectedEOF => self.payload.UnexpectedEOF.partial_cmp(&other.payload.UnexpectedEOF),
                }
            },
        }
    }
}

impl core::hash::Hash for ReadExactlyResult {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_ReadExactlyResult::*;

        unsafe {
            match self.discriminant {
                Error => self.payload.Error.hash(state),
                Read => self.payload.Read.hash(state),
                UnexpectedEOF => self.payload.UnexpectedEOF.hash(state),
            }
        }
    }
}

impl ReadExactlyResult {

    pub fn unwrap_Error(mut self) -> StreamErr {
        debug_assert_eq!(self.discriminant, discriminant_ReadExactlyResult::Error);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Error) }
    }

    pub fn is_Error(&self) -> bool {
        matches!(self.discriminant, discriminant_ReadExactlyResult::Error)
    }

    pub fn unwrap_Read(mut self) -> roc_std::RocList<u8> {
        debug_assert_eq!(self.discriminant, discriminant_ReadExactlyResult::Read);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Read) }
    }

    pub fn is_Read(&self) -> bool {
        matches!(self.discriminant, discriminant_ReadExactlyResult::Read)
    }

    pub fn is_UnexpectedEOF(&self) -> bool {
        matches!(self.discriminant, discriminant_ReadExactlyResult::UnexpectedEOF)
    }
}



impl ReadExactlyResult {

    pub fn Error(payload: StreamErr) -> Self {
        Self {
            discriminant: discriminant_ReadExactlyResult::Error,
            payload: union_ReadExactlyResult {
                Error: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn Read(payload: roc_std::RocList<u8>) -> Self {
        Self {
            discriminant: discriminant_ReadExactlyResult::Read,
            payload: union_ReadExactlyResult {
                Read: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn UnexpectedEOF() -> Self {
        Self {
            discriminant: discriminant_ReadExactlyResult::UnexpectedEOF,
            payload: union_ReadExactlyResult {
                UnexpectedEOF: (),
            }
        }
    }
}

impl Drop for ReadExactlyResult {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_ReadExactlyResult::Error => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.Error) },
            discriminant_ReadExactlyResult::Read => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.Read) },
            discriminant_ReadExactlyResult::UnexpectedEOF => {}
        }
    }
}

#[derive(Clone, Default, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(transparent)]
pub struct U4 {
     f0: roc_std::RocStr,
}

impl U4 {
    /// A tag named ``MimeType``, with the given payload.
    pub fn MimeType(f0: roc_std::RocStr) -> Self {
        Self {
            f0
        }
    }

    /// Since `U4` only has one tag (namely, `MimeType`),
    /// convert it to `MimeType`'s payload.
    pub fn into_MimeType(self) -> roc_std::RocStr {
        self.f0
    }

    /// Since `U4` only has one tag (namely, `MimeType`),
    /// convert it to `MimeType`'s payload.
    pub fn as_MimeType(&self) -> &roc_std::RocStr {
        &self.f0
    }
}


impl core::fmt::Debug for U4 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.debug_tuple("U4::MimeType")
                .field(&self.f0)
                .finish()
    }
}

#[derive(Clone, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct Body_Body {
    pub f0: U4,
    pub f1: roc_std::RocList<u8>,
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_Body {
    Body = 0,
    EmptyBody = 1,
}

impl core::fmt::Debug for discriminant_Body {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Body => f.write_str("discriminant_Body::Body"),
            Self::EmptyBody => f.write_str("discriminant_Body::EmptyBody"),
        }
    }
}

#[repr(C, align(4))]
pub union union_Body {
    Body: core::mem::ManuallyDrop<Body_Body>,
    EmptyBody: (),
}

const _SIZE_CHECK_union_Body: () = assert!(core::mem::size_of::<union_Body>() == 28);
const _ALIGN_CHECK_union_Body: () = assert!(core::mem::align_of::<union_Body>() == 4);

const _SIZE_CHECK_Body: () = assert!(core::mem::size_of::<Body>() == 28);
const _ALIGN_CHECK_Body: () = assert!(core::mem::align_of::<Body>() == 4);

impl Body {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Body {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_Body>(*bytes.as_ptr().add(24))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_Body) {
        let discriminant_ptr: *mut discriminant_Body = (self as *mut Body).cast();

        unsafe {
            *(discriminant_ptr.add(24)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct Body {
    payload: union_Body,
    discriminant: discriminant_Body,
}

impl Clone for Body {
    fn clone(&self) -> Self {
        use discriminant_Body::*;

        let payload = unsafe {
            match self.discriminant {
                Body => union_Body {
                    Body: self.payload.Body.clone(),
                },
                EmptyBody => union_Body {
                    EmptyBody: self.payload.EmptyBody.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for Body {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_Body::*;

        unsafe {
            match self.discriminant {
                Body => {
                    let field: &Body_Body = &self.payload.Body;
                    f.debug_tuple("Body::Body").field(field).finish()
                },
                EmptyBody => {
                    let field: &() = &self.payload.EmptyBody;
                    f.debug_tuple("Body::EmptyBody").field(field).finish()
                },
            }
        }
    }
}

impl Eq for Body {}

impl PartialEq for Body {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_Body::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                Body => self.payload.Body == other.payload.Body,
                EmptyBody => self.payload.EmptyBody == other.payload.EmptyBody,
            }
        }
    }
}

impl Ord for Body {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for Body {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_Body::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    Body => self.payload.Body.partial_cmp(&other.payload.Body),
                    EmptyBody => self.payload.EmptyBody.partial_cmp(&other.payload.EmptyBody),
                }
            },
        }
    }
}

impl core::hash::Hash for Body {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_Body::*;

        unsafe {
            match self.discriminant {
                Body => self.payload.Body.hash(state),
                EmptyBody => self.payload.EmptyBody.hash(state),
            }
        }
    }
}

impl Body {

    pub fn unwrap_Body(mut self) -> Body_Body {
        debug_assert_eq!(self.discriminant, discriminant_Body::Body);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Body) }
    }

    pub fn is_Body(&self) -> bool {
        matches!(self.discriminant, discriminant_Body::Body)
    }

    pub fn is_EmptyBody(&self) -> bool {
        matches!(self.discriminant, discriminant_Body::EmptyBody)
    }
}



impl Body {

    pub fn Body(payload: Body_Body) -> Self {
        Self {
            discriminant: discriminant_Body::Body,
            payload: union_Body {
                Body: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn EmptyBody() -> Self {
        Self {
            discriminant: discriminant_Body::EmptyBody,
            payload: union_Body {
                EmptyBody: (),
            }
        }
    }
}

impl Drop for Body {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_Body::Body => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.Body) },
            discriminant_Body::EmptyBody => {}
        }
    }
}

#[derive(Clone, Default, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct Header {
     f0: roc_std::RocStr,
     f1: roc_std::RocStr,
}

impl Header {
    /// A tag named ``Header``, with the given payload.
    pub fn Header(f0: roc_std::RocStr, f1: roc_std::RocStr) -> Self {
        Self {
            f0
            f1
        }
    }

    /// Since `Header` only has one tag (namely, `Header`),
    /// convert it to `Header`'s payload.
    pub fn into_Header(self) -> (roc_std::RocStr, roc_std::RocStr) {
        (self.f0, self.f1)
    }

    /// Since `Header` only has one tag (namely, `Header`),
    /// convert it to `Header`'s payload.
    pub fn as_Header(&self) -> (&roc_std::RocStr, &roc_std::RocStr) {
        (&self.f0, &self.f1)
    }
}


impl core::fmt::Debug for Header {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.debug_tuple("Header::Header")
                .field(&self.f0)
                .field(&self.f1)
                .finish()
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_TimeoutConfig {
    NoTimeout = 0,
    TimeoutMilliseconds = 1,
}

impl core::fmt::Debug for discriminant_TimeoutConfig {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::NoTimeout => f.write_str("discriminant_TimeoutConfig::NoTimeout"),
            Self::TimeoutMilliseconds => f.write_str("discriminant_TimeoutConfig::TimeoutMilliseconds"),
        }
    }
}

#[repr(C, align(4))]
pub union union_TimeoutConfig {
    NoTimeout: (),
    TimeoutMilliseconds: u64,
}

const _SIZE_CHECK_union_TimeoutConfig: () = assert!(core::mem::size_of::<union_TimeoutConfig>() == 8);
const _ALIGN_CHECK_union_TimeoutConfig: () = assert!(core::mem::align_of::<union_TimeoutConfig>() == 4);

const _SIZE_CHECK_TimeoutConfig: () = assert!(core::mem::size_of::<TimeoutConfig>() == 12);
const _ALIGN_CHECK_TimeoutConfig: () = assert!(core::mem::align_of::<TimeoutConfig>() == 4);

impl TimeoutConfig {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_TimeoutConfig {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_TimeoutConfig>(*bytes.as_ptr().add(8))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_TimeoutConfig) {
        let discriminant_ptr: *mut discriminant_TimeoutConfig = (self as *mut TimeoutConfig).cast();

        unsafe {
            *(discriminant_ptr.add(8)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct TimeoutConfig {
    payload: union_TimeoutConfig,
    discriminant: discriminant_TimeoutConfig,
}

impl Clone for TimeoutConfig {
    fn clone(&self) -> Self {
        use discriminant_TimeoutConfig::*;

        let payload = unsafe {
            match self.discriminant {
                NoTimeout => union_TimeoutConfig {
                    NoTimeout: self.payload.NoTimeout.clone(),
                },
                TimeoutMilliseconds => union_TimeoutConfig {
                    TimeoutMilliseconds: self.payload.TimeoutMilliseconds.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for TimeoutConfig {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_TimeoutConfig::*;

        unsafe {
            match self.discriminant {
                NoTimeout => {
                    let field: &() = &self.payload.NoTimeout;
                    f.debug_tuple("TimeoutConfig::NoTimeout").field(field).finish()
                },
                TimeoutMilliseconds => {
                    let field: &u64 = &self.payload.TimeoutMilliseconds;
                    f.debug_tuple("TimeoutConfig::TimeoutMilliseconds").field(field).finish()
                },
            }
        }
    }
}

impl Eq for TimeoutConfig {}

impl PartialEq for TimeoutConfig {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_TimeoutConfig::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                NoTimeout => self.payload.NoTimeout == other.payload.NoTimeout,
                TimeoutMilliseconds => self.payload.TimeoutMilliseconds == other.payload.TimeoutMilliseconds,
            }
        }
    }
}

impl Ord for TimeoutConfig {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for TimeoutConfig {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_TimeoutConfig::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    NoTimeout => self.payload.NoTimeout.partial_cmp(&other.payload.NoTimeout),
                    TimeoutMilliseconds => self.payload.TimeoutMilliseconds.partial_cmp(&other.payload.TimeoutMilliseconds),
                }
            },
        }
    }
}

impl core::hash::Hash for TimeoutConfig {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_TimeoutConfig::*;

        unsafe {
            match self.discriminant {
                NoTimeout => self.payload.NoTimeout.hash(state),
                TimeoutMilliseconds => self.payload.TimeoutMilliseconds.hash(state),
            }
        }
    }
}

impl TimeoutConfig {

    pub fn is_NoTimeout(&self) -> bool {
        matches!(self.discriminant, discriminant_TimeoutConfig::NoTimeout)
    }

    pub fn unwrap_TimeoutMilliseconds(mut self) -> u64 {
        debug_assert_eq!(self.discriminant, discriminant_TimeoutConfig::TimeoutMilliseconds);
        unsafe { self.payload.TimeoutMilliseconds }
    }

    pub fn is_TimeoutMilliseconds(&self) -> bool {
        matches!(self.discriminant, discriminant_TimeoutConfig::TimeoutMilliseconds)
    }
}



impl TimeoutConfig {

    pub fn NoTimeout() -> Self {
        Self {
            discriminant: discriminant_TimeoutConfig::NoTimeout,
            payload: union_TimeoutConfig {
                NoTimeout: (),
            }
        }
    }

    pub fn TimeoutMilliseconds(payload: u64) -> Self {
        Self {
            discriminant: discriminant_TimeoutConfig::TimeoutMilliseconds,
            payload: union_TimeoutConfig {
                TimeoutMilliseconds: payload,
            }
        }
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum Method {
    Connect = 0,
    Delete = 1,
    Get = 2,
    Head = 3,
    Options = 4,
    Patch = 5,
    Post = 6,
    Put = 7,
    Trace = 8,
}

impl core::fmt::Debug for Method {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Connect => f.write_str("Method::Connect"),
            Self::Delete => f.write_str("Method::Delete"),
            Self::Get => f.write_str("Method::Get"),
            Self::Head => f.write_str("Method::Head"),
            Self::Options => f.write_str("Method::Options"),
            Self::Patch => f.write_str("Method::Patch"),
            Self::Post => f.write_str("Method::Post"),
            Self::Put => f.write_str("Method::Put"),
            Self::Trace => f.write_str("Method::Trace"),
        }
    }
}

#[derive(Clone, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct Request {
    pub body: Body,
    pub headers: roc_std::RocList<Header>,
    pub timeout: TimeoutConfig,
    pub url: roc_std::RocStr,
    pub method: Method,
}

#[derive(Clone, Default, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct Part {
     f0: roc_std::RocStr,
     f1: roc_std::RocList<u8>,
}

impl Part {
    /// A tag named ``Part``, with the given payload.
    pub fn Part(f0: roc_std::RocStr, f1: roc_std::RocList<u8>) -> Self {
        Self {
            f0
            f1
        }
    }

    /// Since `Part` only has one tag (namely, `Part`),
    /// convert it to `Part`'s payload.
    pub fn into_Part(self) -> (roc_std::RocStr, roc_std::RocList<u8>) {
        (self.f0, self.f1)
    }

    /// Since `Part` only has one tag (namely, `Part`),
    /// convert it to `Part`'s payload.
    pub fn as_Part(&self) -> (&roc_std::RocStr, &roc_std::RocList<u8>) {
        (&self.f0, &self.f1)
    }
}


impl core::fmt::Debug for Part {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.debug_tuple("Part::Part")
                .field(&self.f0)
                .field(&self.f1)
                .finish()
    }
}

#[derive(Clone, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct Metadata {
    pub headers: roc_std::RocList<Header>,
    pub statusText: roc_std::RocStr,
    pub url: roc_std::RocStr,
    pub statusCode: u16,
}

#[derive(Clone, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct Response_BadStatus {
    pub f0: Metadata,
    pub f1: roc_std::RocList<u8>,
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_Response {
    BadRequest = 0,
    BadStatus = 1,
    GoodStatus = 2,
    NetworkError = 3,
    Timeout = 4,
}

impl core::fmt::Debug for discriminant_Response {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::BadRequest => f.write_str("discriminant_Response::BadRequest"),
            Self::BadStatus => f.write_str("discriminant_Response::BadStatus"),
            Self::GoodStatus => f.write_str("discriminant_Response::GoodStatus"),
            Self::NetworkError => f.write_str("discriminant_Response::NetworkError"),
            Self::Timeout => f.write_str("discriminant_Response::Timeout"),
        }
    }
}

#[repr(C, align(4))]
pub union union_Response {
    BadRequest: core::mem::ManuallyDrop<roc_std::RocStr>,
    BadStatus: core::mem::ManuallyDrop<Response_BadStatus>,
    GoodStatus: core::mem::ManuallyDrop<Response_BadStatus>,
    NetworkError: (),
    Timeout: (),
}

const _SIZE_CHECK_union_Response: () = assert!(core::mem::size_of::<union_Response>() == 56);
const _ALIGN_CHECK_union_Response: () = assert!(core::mem::align_of::<union_Response>() == 4);

const _SIZE_CHECK_Response: () = assert!(core::mem::size_of::<Response>() == 56);
const _ALIGN_CHECK_Response: () = assert!(core::mem::align_of::<Response>() == 4);

impl Response {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Response {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_Response>(*bytes.as_ptr().add(52))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_Response) {
        let discriminant_ptr: *mut discriminant_Response = (self as *mut Response).cast();

        unsafe {
            *(discriminant_ptr.add(52)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct Response {
    payload: union_Response,
    discriminant: discriminant_Response,
}

impl Clone for Response {
    fn clone(&self) -> Self {
        use discriminant_Response::*;

        let payload = unsafe {
            match self.discriminant {
                BadRequest => union_Response {
                    BadRequest: self.payload.BadRequest.clone(),
                },
                BadStatus => union_Response {
                    BadStatus: self.payload.BadStatus.clone(),
                },
                GoodStatus => union_Response {
                    GoodStatus: self.payload.GoodStatus.clone(),
                },
                NetworkError => union_Response {
                    NetworkError: self.payload.NetworkError.clone(),
                },
                Timeout => union_Response {
                    Timeout: self.payload.Timeout.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for Response {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_Response::*;

        unsafe {
            match self.discriminant {
                BadRequest => {
                    let field: &roc_std::RocStr = &self.payload.BadRequest;
                    f.debug_tuple("Response::BadRequest").field(field).finish()
                },
                BadStatus => {
                    let field: &Response_BadStatus = &self.payload.BadStatus;
                    f.debug_tuple("Response::BadStatus").field(field).finish()
                },
                GoodStatus => {
                    let field: &Response_BadStatus = &self.payload.GoodStatus;
                    f.debug_tuple("Response::GoodStatus").field(field).finish()
                },
                NetworkError => {
                    let field: &() = &self.payload.NetworkError;
                    f.debug_tuple("Response::NetworkError").field(field).finish()
                },
                Timeout => {
                    let field: &() = &self.payload.Timeout;
                    f.debug_tuple("Response::Timeout").field(field).finish()
                },
            }
        }
    }
}

impl Eq for Response {}

impl PartialEq for Response {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_Response::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                BadRequest => self.payload.BadRequest == other.payload.BadRequest,
                BadStatus => self.payload.BadStatus == other.payload.BadStatus,
                GoodStatus => self.payload.GoodStatus == other.payload.GoodStatus,
                NetworkError => self.payload.NetworkError == other.payload.NetworkError,
                Timeout => self.payload.Timeout == other.payload.Timeout,
            }
        }
    }
}

impl Ord for Response {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for Response {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_Response::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    BadRequest => self.payload.BadRequest.partial_cmp(&other.payload.BadRequest),
                    BadStatus => self.payload.BadStatus.partial_cmp(&other.payload.BadStatus),
                    GoodStatus => self.payload.GoodStatus.partial_cmp(&other.payload.GoodStatus),
                    NetworkError => self.payload.NetworkError.partial_cmp(&other.payload.NetworkError),
                    Timeout => self.payload.Timeout.partial_cmp(&other.payload.Timeout),
                }
            },
        }
    }
}

impl core::hash::Hash for Response {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_Response::*;

        unsafe {
            match self.discriminant {
                BadRequest => self.payload.BadRequest.hash(state),
                BadStatus => self.payload.BadStatus.hash(state),
                GoodStatus => self.payload.GoodStatus.hash(state),
                NetworkError => self.payload.NetworkError.hash(state),
                Timeout => self.payload.Timeout.hash(state),
            }
        }
    }
}

impl Response {

    pub fn unwrap_BadRequest(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_Response::BadRequest);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.BadRequest) }
    }

    pub fn is_BadRequest(&self) -> bool {
        matches!(self.discriminant, discriminant_Response::BadRequest)
    }

    pub fn unwrap_BadStatus(mut self) -> Response_BadStatus {
        debug_assert_eq!(self.discriminant, discriminant_Response::BadStatus);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.BadStatus) }
    }

    pub fn is_BadStatus(&self) -> bool {
        matches!(self.discriminant, discriminant_Response::BadStatus)
    }

    pub fn unwrap_GoodStatus(mut self) -> Response_BadStatus {
        debug_assert_eq!(self.discriminant, discriminant_Response::GoodStatus);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.GoodStatus) }
    }

    pub fn is_GoodStatus(&self) -> bool {
        matches!(self.discriminant, discriminant_Response::GoodStatus)
    }

    pub fn is_NetworkError(&self) -> bool {
        matches!(self.discriminant, discriminant_Response::NetworkError)
    }

    pub fn is_Timeout(&self) -> bool {
        matches!(self.discriminant, discriminant_Response::Timeout)
    }
}



impl Response {

    pub fn BadRequest(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_Response::BadRequest,
            payload: union_Response {
                BadRequest: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn BadStatus(payload: Response_BadStatus) -> Self {
        Self {
            discriminant: discriminant_Response::BadStatus,
            payload: union_Response {
                BadStatus: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn GoodStatus(payload: Response_BadStatus) -> Self {
        Self {
            discriminant: discriminant_Response::GoodStatus,
            payload: union_Response {
                GoodStatus: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn NetworkError() -> Self {
        Self {
            discriminant: discriminant_Response::NetworkError,
            payload: union_Response {
                NetworkError: (),
            }
        }
    }

    pub fn Timeout() -> Self {
        Self {
            discriminant: discriminant_Response::Timeout,
            payload: union_Response {
                Timeout: (),
            }
        }
    }
}

impl Drop for Response {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_Response::BadRequest => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.BadRequest) },
            discriminant_Response::BadStatus => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.BadStatus) },
            discriminant_Response::GoodStatus => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.GoodStatus) },
            discriminant_Response::NetworkError => {}
            discriminant_Response::Timeout => {}
        }
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_Error {
    BadBody = 0,
    BadRequest = 1,
    BadStatus = 2,
    NetworkError = 3,
    Timeout = 4,
}

impl core::fmt::Debug for discriminant_Error {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::BadBody => f.write_str("discriminant_Error::BadBody"),
            Self::BadRequest => f.write_str("discriminant_Error::BadRequest"),
            Self::BadStatus => f.write_str("discriminant_Error::BadStatus"),
            Self::NetworkError => f.write_str("discriminant_Error::NetworkError"),
            Self::Timeout => f.write_str("discriminant_Error::Timeout"),
        }
    }
}

#[repr(C, align(4))]
pub union union_Error {
    BadBody: core::mem::ManuallyDrop<roc_std::RocStr>,
    BadRequest: core::mem::ManuallyDrop<roc_std::RocStr>,
    BadStatus: u16,
    NetworkError: (),
    Timeout: (),
}

const _SIZE_CHECK_union_Error: () = assert!(core::mem::size_of::<union_Error>() == 12);
const _ALIGN_CHECK_union_Error: () = assert!(core::mem::align_of::<union_Error>() == 4);

const _SIZE_CHECK_Error: () = assert!(core::mem::size_of::<Error>() == 16);
const _ALIGN_CHECK_Error: () = assert!(core::mem::align_of::<Error>() == 4);

impl Error {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Error {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_Error>(*bytes.as_ptr().add(12))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_Error) {
        let discriminant_ptr: *mut discriminant_Error = (self as *mut Error).cast();

        unsafe {
            *(discriminant_ptr.add(12)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct Error {
    payload: union_Error,
    discriminant: discriminant_Error,
}

impl Clone for Error {
    fn clone(&self) -> Self {
        use discriminant_Error::*;

        let payload = unsafe {
            match self.discriminant {
                BadBody => union_Error {
                    BadBody: self.payload.BadBody.clone(),
                },
                BadRequest => union_Error {
                    BadRequest: self.payload.BadRequest.clone(),
                },
                BadStatus => union_Error {
                    BadStatus: self.payload.BadStatus.clone(),
                },
                NetworkError => union_Error {
                    NetworkError: self.payload.NetworkError.clone(),
                },
                Timeout => union_Error {
                    Timeout: self.payload.Timeout.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for Error {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_Error::*;

        unsafe {
            match self.discriminant {
                BadBody => {
                    let field: &roc_std::RocStr = &self.payload.BadBody;
                    f.debug_tuple("Error::BadBody").field(field).finish()
                },
                BadRequest => {
                    let field: &roc_std::RocStr = &self.payload.BadRequest;
                    f.debug_tuple("Error::BadRequest").field(field).finish()
                },
                BadStatus => {
                    let field: &u16 = &self.payload.BadStatus;
                    f.debug_tuple("Error::BadStatus").field(field).finish()
                },
                NetworkError => {
                    let field: &() = &self.payload.NetworkError;
                    f.debug_tuple("Error::NetworkError").field(field).finish()
                },
                Timeout => {
                    let field: &() = &self.payload.Timeout;
                    f.debug_tuple("Error::Timeout").field(field).finish()
                },
            }
        }
    }
}

impl Eq for Error {}

impl PartialEq for Error {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_Error::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                BadBody => self.payload.BadBody == other.payload.BadBody,
                BadRequest => self.payload.BadRequest == other.payload.BadRequest,
                BadStatus => self.payload.BadStatus == other.payload.BadStatus,
                NetworkError => self.payload.NetworkError == other.payload.NetworkError,
                Timeout => self.payload.Timeout == other.payload.Timeout,
            }
        }
    }
}

impl Ord for Error {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for Error {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_Error::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    BadBody => self.payload.BadBody.partial_cmp(&other.payload.BadBody),
                    BadRequest => self.payload.BadRequest.partial_cmp(&other.payload.BadRequest),
                    BadStatus => self.payload.BadStatus.partial_cmp(&other.payload.BadStatus),
                    NetworkError => self.payload.NetworkError.partial_cmp(&other.payload.NetworkError),
                    Timeout => self.payload.Timeout.partial_cmp(&other.payload.Timeout),
                }
            },
        }
    }
}

impl core::hash::Hash for Error {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_Error::*;

        unsafe {
            match self.discriminant {
                BadBody => self.payload.BadBody.hash(state),
                BadRequest => self.payload.BadRequest.hash(state),
                BadStatus => self.payload.BadStatus.hash(state),
                NetworkError => self.payload.NetworkError.hash(state),
                Timeout => self.payload.Timeout.hash(state),
            }
        }
    }
}

impl Error {

    pub fn unwrap_BadBody(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_Error::BadBody);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.BadBody) }
    }

    pub fn is_BadBody(&self) -> bool {
        matches!(self.discriminant, discriminant_Error::BadBody)
    }

    pub fn unwrap_BadRequest(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_Error::BadRequest);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.BadRequest) }
    }

    pub fn is_BadRequest(&self) -> bool {
        matches!(self.discriminant, discriminant_Error::BadRequest)
    }

    pub fn unwrap_BadStatus(mut self) -> u16 {
        debug_assert_eq!(self.discriminant, discriminant_Error::BadStatus);
        unsafe { self.payload.BadStatus }
    }

    pub fn is_BadStatus(&self) -> bool {
        matches!(self.discriminant, discriminant_Error::BadStatus)
    }

    pub fn is_NetworkError(&self) -> bool {
        matches!(self.discriminant, discriminant_Error::NetworkError)
    }

    pub fn is_Timeout(&self) -> bool {
        matches!(self.discriminant, discriminant_Error::Timeout)
    }
}



impl Error {

    pub fn BadBody(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_Error::BadBody,
            payload: union_Error {
                BadBody: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn BadRequest(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_Error::BadRequest,
            payload: union_Error {
                BadRequest: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn BadStatus(payload: u16) -> Self {
        Self {
            discriminant: discriminant_Error::BadStatus,
            payload: union_Error {
                BadStatus: payload,
            }
        }
    }

    pub fn NetworkError() -> Self {
        Self {
            discriminant: discriminant_Error::NetworkError,
            payload: union_Error {
                NetworkError: (),
            }
        }
    }

    pub fn Timeout() -> Self {
        Self {
            discriminant: discriminant_Error::Timeout,
            payload: union_Error {
                Timeout: (),
            }
        }
    }
}

impl Drop for Error {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_Error::BadBody => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.BadBody) },
            discriminant_Error::BadRequest => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.BadRequest) },
            discriminant_Error::BadStatus => {}
            discriminant_Error::NetworkError => {}
            discriminant_Error::Timeout => {}
        }
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_IncludeTheseTypes {
    A = 0,
    B = 1,
    C = 2,
    D = 3,
    E = 4,
    F = 5,
    G = 6,
    H = 7,
    I = 8,
    J = 9,
    K = 10,
    L = 11,
    M = 12,
    N = 13,
    O = 14,
    P = 15,
    Q = 16,
    R = 17,
    S = 18,
    T = 19,
    U = 20,
    V = 21,
    W = 22,
}

impl core::fmt::Debug for discriminant_IncludeTheseTypes {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::A => f.write_str("discriminant_IncludeTheseTypes::A"),
            Self::B => f.write_str("discriminant_IncludeTheseTypes::B"),
            Self::C => f.write_str("discriminant_IncludeTheseTypes::C"),
            Self::D => f.write_str("discriminant_IncludeTheseTypes::D"),
            Self::E => f.write_str("discriminant_IncludeTheseTypes::E"),
            Self::F => f.write_str("discriminant_IncludeTheseTypes::F"),
            Self::G => f.write_str("discriminant_IncludeTheseTypes::G"),
            Self::H => f.write_str("discriminant_IncludeTheseTypes::H"),
            Self::I => f.write_str("discriminant_IncludeTheseTypes::I"),
            Self::J => f.write_str("discriminant_IncludeTheseTypes::J"),
            Self::K => f.write_str("discriminant_IncludeTheseTypes::K"),
            Self::L => f.write_str("discriminant_IncludeTheseTypes::L"),
            Self::M => f.write_str("discriminant_IncludeTheseTypes::M"),
            Self::N => f.write_str("discriminant_IncludeTheseTypes::N"),
            Self::O => f.write_str("discriminant_IncludeTheseTypes::O"),
            Self::P => f.write_str("discriminant_IncludeTheseTypes::P"),
            Self::Q => f.write_str("discriminant_IncludeTheseTypes::Q"),
            Self::R => f.write_str("discriminant_IncludeTheseTypes::R"),
            Self::S => f.write_str("discriminant_IncludeTheseTypes::S"),
            Self::T => f.write_str("discriminant_IncludeTheseTypes::T"),
            Self::U => f.write_str("discriminant_IncludeTheseTypes::U"),
            Self::V => f.write_str("discriminant_IncludeTheseTypes::V"),
            Self::W => f.write_str("discriminant_IncludeTheseTypes::W"),
        }
    }
}

#[repr(C, align(4))]
pub union union_IncludeTheseTypes {
    A: core::mem::ManuallyDrop<CommandErr>,
    B: core::mem::ManuallyDrop<Command>,
    C: core::mem::ManuallyDrop<Output>,
    D: IOError,
    E: core::mem::ManuallyDrop<DirEntry>,
    F: core::mem::ManuallyDrop<ReadErr>,
    G: core::mem::ManuallyDrop<WriteErr>,
    H: u32,
    I: core::mem::ManuallyDrop<ConnectErr>,
    J: core::mem::ManuallyDrop<StreamErr>,
    K: core::mem::ManuallyDrop<ConnectResult>,
    L: core::mem::ManuallyDrop<WriteResult>,
    M: core::mem::ManuallyDrop<ReadResult>,
    N: core::mem::ManuallyDrop<ReadExactlyResult>,
    O: core::mem::ManuallyDrop<Request>,
    P: Method,
    Q: core::mem::ManuallyDrop<Header>,
    R: TimeoutConfig,
    S: core::mem::ManuallyDrop<Part>,
    T: core::mem::ManuallyDrop<Body>,
    U: core::mem::ManuallyDrop<Response>,
    V: core::mem::ManuallyDrop<Metadata>,
    W: core::mem::ManuallyDrop<Error>,
}

const _SIZE_CHECK_union_IncludeTheseTypes: () = assert!(core::mem::size_of::<union_IncludeTheseTypes>() == 68);
const _ALIGN_CHECK_union_IncludeTheseTypes: () = assert!(core::mem::align_of::<union_IncludeTheseTypes>() == 4);

const _SIZE_CHECK_IncludeTheseTypes: () = assert!(core::mem::size_of::<IncludeTheseTypes>() == 72);
const _ALIGN_CHECK_IncludeTheseTypes: () = assert!(core::mem::align_of::<IncludeTheseTypes>() == 4);

impl IncludeTheseTypes {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_IncludeTheseTypes {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_IncludeTheseTypes>(*bytes.as_ptr().add(68))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_IncludeTheseTypes) {
        let discriminant_ptr: *mut discriminant_IncludeTheseTypes = (self as *mut IncludeTheseTypes).cast();

        unsafe {
            *(discriminant_ptr.add(68)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct IncludeTheseTypes {
    payload: union_IncludeTheseTypes,
    discriminant: discriminant_IncludeTheseTypes,
}

impl Clone for IncludeTheseTypes {
    fn clone(&self) -> Self {
        use discriminant_IncludeTheseTypes::*;

        let payload = unsafe {
            match self.discriminant {
                A => union_IncludeTheseTypes {
                    A: self.payload.A.clone(),
                },
                B => union_IncludeTheseTypes {
                    B: self.payload.B.clone(),
                },
                C => union_IncludeTheseTypes {
                    C: self.payload.C.clone(),
                },
                D => union_IncludeTheseTypes {
                    D: self.payload.D.clone(),
                },
                E => union_IncludeTheseTypes {
                    E: self.payload.E.clone(),
                },
                F => union_IncludeTheseTypes {
                    F: self.payload.F.clone(),
                },
                G => union_IncludeTheseTypes {
                    G: self.payload.G.clone(),
                },
                H => union_IncludeTheseTypes {
                    H: self.payload.H.clone(),
                },
                I => union_IncludeTheseTypes {
                    I: self.payload.I.clone(),
                },
                J => union_IncludeTheseTypes {
                    J: self.payload.J.clone(),
                },
                K => union_IncludeTheseTypes {
                    K: self.payload.K.clone(),
                },
                L => union_IncludeTheseTypes {
                    L: self.payload.L.clone(),
                },
                M => union_IncludeTheseTypes {
                    M: self.payload.M.clone(),
                },
                N => union_IncludeTheseTypes {
                    N: self.payload.N.clone(),
                },
                O => union_IncludeTheseTypes {
                    O: self.payload.O.clone(),
                },
                P => union_IncludeTheseTypes {
                    P: self.payload.P.clone(),
                },
                Q => union_IncludeTheseTypes {
                    Q: self.payload.Q.clone(),
                },
                R => union_IncludeTheseTypes {
                    R: self.payload.R.clone(),
                },
                S => union_IncludeTheseTypes {
                    S: self.payload.S.clone(),
                },
                T => union_IncludeTheseTypes {
                    T: self.payload.T.clone(),
                },
                U => union_IncludeTheseTypes {
                    U: self.payload.U.clone(),
                },
                V => union_IncludeTheseTypes {
                    V: self.payload.V.clone(),
                },
                W => union_IncludeTheseTypes {
                    W: self.payload.W.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for IncludeTheseTypes {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_IncludeTheseTypes::*;

        unsafe {
            match self.discriminant {
                A => {
                    let field: &CommandErr = &self.payload.A;
                    f.debug_tuple("IncludeTheseTypes::A").field(field).finish()
                },
                B => {
                    let field: &Command = &self.payload.B;
                    f.debug_tuple("IncludeTheseTypes::B").field(field).finish()
                },
                C => {
                    let field: &Output = &self.payload.C;
                    f.debug_tuple("IncludeTheseTypes::C").field(field).finish()
                },
                D => {
                    let field: &IOError = &self.payload.D;
                    f.debug_tuple("IncludeTheseTypes::D").field(field).finish()
                },
                E => {
                    let field: &DirEntry = &self.payload.E;
                    f.debug_tuple("IncludeTheseTypes::E").field(field).finish()
                },
                F => {
                    let field: &ReadErr = &self.payload.F;
                    f.debug_tuple("IncludeTheseTypes::F").field(field).finish()
                },
                G => {
                    let field: &WriteErr = &self.payload.G;
                    f.debug_tuple("IncludeTheseTypes::G").field(field).finish()
                },
                H => {
                    let field: &u32 = &self.payload.H;
                    f.debug_tuple("IncludeTheseTypes::H").field(field).finish()
                },
                I => {
                    let field: &ConnectErr = &self.payload.I;
                    f.debug_tuple("IncludeTheseTypes::I").field(field).finish()
                },
                J => {
                    let field: &StreamErr = &self.payload.J;
                    f.debug_tuple("IncludeTheseTypes::J").field(field).finish()
                },
                K => {
                    let field: &ConnectResult = &self.payload.K;
                    f.debug_tuple("IncludeTheseTypes::K").field(field).finish()
                },
                L => {
                    let field: &WriteResult = &self.payload.L;
                    f.debug_tuple("IncludeTheseTypes::L").field(field).finish()
                },
                M => {
                    let field: &ReadResult = &self.payload.M;
                    f.debug_tuple("IncludeTheseTypes::M").field(field).finish()
                },
                N => {
                    let field: &ReadExactlyResult = &self.payload.N;
                    f.debug_tuple("IncludeTheseTypes::N").field(field).finish()
                },
                O => {
                    let field: &Request = &self.payload.O;
                    f.debug_tuple("IncludeTheseTypes::O").field(field).finish()
                },
                P => {
                    let field: &Method = &self.payload.P;
                    f.debug_tuple("IncludeTheseTypes::P").field(field).finish()
                },
                Q => {
                    let field: &Header = &self.payload.Q;
                    f.debug_tuple("IncludeTheseTypes::Q").field(field).finish()
                },
                R => {
                    let field: &TimeoutConfig = &self.payload.R;
                    f.debug_tuple("IncludeTheseTypes::R").field(field).finish()
                },
                S => {
                    let field: &Part = &self.payload.S;
                    f.debug_tuple("IncludeTheseTypes::S").field(field).finish()
                },
                T => {
                    let field: &Body = &self.payload.T;
                    f.debug_tuple("IncludeTheseTypes::T").field(field).finish()
                },
                U => {
                    let field: &Response = &self.payload.U;
                    f.debug_tuple("IncludeTheseTypes::U").field(field).finish()
                },
                V => {
                    let field: &Metadata = &self.payload.V;
                    f.debug_tuple("IncludeTheseTypes::V").field(field).finish()
                },
                W => {
                    let field: &Error = &self.payload.W;
                    f.debug_tuple("IncludeTheseTypes::W").field(field).finish()
                },
            }
        }
    }
}

impl Eq for IncludeTheseTypes {}

impl PartialEq for IncludeTheseTypes {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_IncludeTheseTypes::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                A => self.payload.A == other.payload.A,
                B => self.payload.B == other.payload.B,
                C => self.payload.C == other.payload.C,
                D => self.payload.D == other.payload.D,
                E => self.payload.E == other.payload.E,
                F => self.payload.F == other.payload.F,
                G => self.payload.G == other.payload.G,
                H => self.payload.H == other.payload.H,
                I => self.payload.I == other.payload.I,
                J => self.payload.J == other.payload.J,
                K => self.payload.K == other.payload.K,
                L => self.payload.L == other.payload.L,
                M => self.payload.M == other.payload.M,
                N => self.payload.N == other.payload.N,
                O => self.payload.O == other.payload.O,
                P => self.payload.P == other.payload.P,
                Q => self.payload.Q == other.payload.Q,
                R => self.payload.R == other.payload.R,
                S => self.payload.S == other.payload.S,
                T => self.payload.T == other.payload.T,
                U => self.payload.U == other.payload.U,
                V => self.payload.V == other.payload.V,
                W => self.payload.W == other.payload.W,
            }
        }
    }
}

impl Ord for IncludeTheseTypes {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for IncludeTheseTypes {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_IncludeTheseTypes::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    A => self.payload.A.partial_cmp(&other.payload.A),
                    B => self.payload.B.partial_cmp(&other.payload.B),
                    C => self.payload.C.partial_cmp(&other.payload.C),
                    D => self.payload.D.partial_cmp(&other.payload.D),
                    E => self.payload.E.partial_cmp(&other.payload.E),
                    F => self.payload.F.partial_cmp(&other.payload.F),
                    G => self.payload.G.partial_cmp(&other.payload.G),
                    H => self.payload.H.partial_cmp(&other.payload.H),
                    I => self.payload.I.partial_cmp(&other.payload.I),
                    J => self.payload.J.partial_cmp(&other.payload.J),
                    K => self.payload.K.partial_cmp(&other.payload.K),
                    L => self.payload.L.partial_cmp(&other.payload.L),
                    M => self.payload.M.partial_cmp(&other.payload.M),
                    N => self.payload.N.partial_cmp(&other.payload.N),
                    O => self.payload.O.partial_cmp(&other.payload.O),
                    P => self.payload.P.partial_cmp(&other.payload.P),
                    Q => self.payload.Q.partial_cmp(&other.payload.Q),
                    R => self.payload.R.partial_cmp(&other.payload.R),
                    S => self.payload.S.partial_cmp(&other.payload.S),
                    T => self.payload.T.partial_cmp(&other.payload.T),
                    U => self.payload.U.partial_cmp(&other.payload.U),
                    V => self.payload.V.partial_cmp(&other.payload.V),
                    W => self.payload.W.partial_cmp(&other.payload.W),
                }
            },
        }
    }
}

impl core::hash::Hash for IncludeTheseTypes {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_IncludeTheseTypes::*;

        unsafe {
            match self.discriminant {
                A => self.payload.A.hash(state),
                B => self.payload.B.hash(state),
                C => self.payload.C.hash(state),
                D => self.payload.D.hash(state),
                E => self.payload.E.hash(state),
                F => self.payload.F.hash(state),
                G => self.payload.G.hash(state),
                H => self.payload.H.hash(state),
                I => self.payload.I.hash(state),
                J => self.payload.J.hash(state),
                K => self.payload.K.hash(state),
                L => self.payload.L.hash(state),
                M => self.payload.M.hash(state),
                N => self.payload.N.hash(state),
                O => self.payload.O.hash(state),
                P => self.payload.P.hash(state),
                Q => self.payload.Q.hash(state),
                R => self.payload.R.hash(state),
                S => self.payload.S.hash(state),
                T => self.payload.T.hash(state),
                U => self.payload.U.hash(state),
                V => self.payload.V.hash(state),
                W => self.payload.W.hash(state),
            }
        }
    }
}

impl IncludeTheseTypes {

    pub fn unwrap_A(mut self) -> CommandErr {
        debug_assert_eq!(self.discriminant, discriminant_IncludeTheseTypes::A);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.A) }
    }

    pub fn is_A(&self) -> bool {
        matches!(self.discriminant, discriminant_IncludeTheseTypes::A)
    }

    pub fn unwrap_B(mut self) -> Command {
        debug_assert_eq!(self.discriminant, discriminant_IncludeTheseTypes::B);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.B) }
    }

    pub fn is_B(&self) -> bool {
        matches!(self.discriminant, discriminant_IncludeTheseTypes::B)
    }

    pub fn unwrap_C(mut self) -> Output {
        debug_assert_eq!(self.discriminant, discriminant_IncludeTheseTypes::C);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.C) }
    }

    pub fn is_C(&self) -> bool {
        matches!(self.discriminant, discriminant_IncludeTheseTypes::C)
    }

    pub fn unwrap_D(mut self) -> IOError {
        debug_assert_eq!(self.discriminant, discriminant_IncludeTheseTypes::D);
        unsafe { self.payload.D }
    }

    pub fn is_D(&self) -> bool {
        matches!(self.discriminant, discriminant_IncludeTheseTypes::D)
    }

    pub fn unwrap_E(mut self) -> DirEntry {
        debug_assert_eq!(self.discriminant, discriminant_IncludeTheseTypes::E);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.E) }
    }

    pub fn is_E(&self) -> bool {
        matches!(self.discriminant, discriminant_IncludeTheseTypes::E)
    }

    pub fn unwrap_F(mut self) -> ReadErr {
        debug_assert_eq!(self.discriminant, discriminant_IncludeTheseTypes::F);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.F) }
    }

    pub fn is_F(&self) -> bool {
        matches!(self.discriminant, discriminant_IncludeTheseTypes::F)
    }

    pub fn unwrap_G(mut self) -> WriteErr {
        debug_assert_eq!(self.discriminant, discriminant_IncludeTheseTypes::G);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.G) }
    }

    pub fn is_G(&self) -> bool {
        matches!(self.discriminant, discriminant_IncludeTheseTypes::G)
    }

    pub fn unwrap_H(mut self) -> u32 {
        debug_assert_eq!(self.discriminant, discriminant_IncludeTheseTypes::H);
        unsafe { self.payload.H }
    }

    pub fn is_H(&self) -> bool {
        matches!(self.discriminant, discriminant_IncludeTheseTypes::H)
    }

    pub fn unwrap_I(mut self) -> ConnectErr {
        debug_assert_eq!(self.discriminant, discriminant_IncludeTheseTypes::I);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.I) }
    }

    pub fn is_I(&self) -> bool {
        matches!(self.discriminant, discriminant_IncludeTheseTypes::I)
    }

    pub fn unwrap_J(mut self) -> StreamErr {
        debug_assert_eq!(self.discriminant, discriminant_IncludeTheseTypes::J);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.J) }
    }

    pub fn is_J(&self) -> bool {
        matches!(self.discriminant, discriminant_IncludeTheseTypes::J)
    }

    pub fn unwrap_K(mut self) -> ConnectResult {
        debug_assert_eq!(self.discriminant, discriminant_IncludeTheseTypes::K);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.K) }
    }

    pub fn is_K(&self) -> bool {
        matches!(self.discriminant, discriminant_IncludeTheseTypes::K)
    }

    pub fn unwrap_L(mut self) -> WriteResult {
        debug_assert_eq!(self.discriminant, discriminant_IncludeTheseTypes::L);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.L) }
    }

    pub fn is_L(&self) -> bool {
        matches!(self.discriminant, discriminant_IncludeTheseTypes::L)
    }

    pub fn unwrap_M(mut self) -> ReadResult {
        debug_assert_eq!(self.discriminant, discriminant_IncludeTheseTypes::M);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.M) }
    }

    pub fn is_M(&self) -> bool {
        matches!(self.discriminant, discriminant_IncludeTheseTypes::M)
    }

    pub fn unwrap_N(mut self) -> ReadExactlyResult {
        debug_assert_eq!(self.discriminant, discriminant_IncludeTheseTypes::N);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.N) }
    }

    pub fn is_N(&self) -> bool {
        matches!(self.discriminant, discriminant_IncludeTheseTypes::N)
    }

    pub fn unwrap_O(mut self) -> Request {
        debug_assert_eq!(self.discriminant, discriminant_IncludeTheseTypes::O);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.O) }
    }

    pub fn is_O(&self) -> bool {
        matches!(self.discriminant, discriminant_IncludeTheseTypes::O)
    }

    pub fn unwrap_P(mut self) -> Method {
        debug_assert_eq!(self.discriminant, discriminant_IncludeTheseTypes::P);
        unsafe { self.payload.P }
    }

    pub fn is_P(&self) -> bool {
        matches!(self.discriminant, discriminant_IncludeTheseTypes::P)
    }

    pub fn unwrap_Q(mut self) -> Header {
        debug_assert_eq!(self.discriminant, discriminant_IncludeTheseTypes::Q);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Q) }
    }

    pub fn is_Q(&self) -> bool {
        matches!(self.discriminant, discriminant_IncludeTheseTypes::Q)
    }

    pub fn unwrap_R(mut self) -> TimeoutConfig {
        debug_assert_eq!(self.discriminant, discriminant_IncludeTheseTypes::R);
        unsafe { self.payload.R }
    }

    pub fn is_R(&self) -> bool {
        matches!(self.discriminant, discriminant_IncludeTheseTypes::R)
    }

    pub fn unwrap_S(mut self) -> Part {
        debug_assert_eq!(self.discriminant, discriminant_IncludeTheseTypes::S);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.S) }
    }

    pub fn is_S(&self) -> bool {
        matches!(self.discriminant, discriminant_IncludeTheseTypes::S)
    }

    pub fn unwrap_T(mut self) -> Body {
        debug_assert_eq!(self.discriminant, discriminant_IncludeTheseTypes::T);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.T) }
    }

    pub fn is_T(&self) -> bool {
        matches!(self.discriminant, discriminant_IncludeTheseTypes::T)
    }

    pub fn unwrap_U(mut self) -> Response {
        debug_assert_eq!(self.discriminant, discriminant_IncludeTheseTypes::U);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.U) }
    }

    pub fn is_U(&self) -> bool {
        matches!(self.discriminant, discriminant_IncludeTheseTypes::U)
    }

    pub fn unwrap_V(mut self) -> Metadata {
        debug_assert_eq!(self.discriminant, discriminant_IncludeTheseTypes::V);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.V) }
    }

    pub fn is_V(&self) -> bool {
        matches!(self.discriminant, discriminant_IncludeTheseTypes::V)
    }

    pub fn unwrap_W(mut self) -> Error {
        debug_assert_eq!(self.discriminant, discriminant_IncludeTheseTypes::W);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.W) }
    }

    pub fn is_W(&self) -> bool {
        matches!(self.discriminant, discriminant_IncludeTheseTypes::W)
    }
}



impl IncludeTheseTypes {

    pub fn A(payload: CommandErr) -> Self {
        Self {
            discriminant: discriminant_IncludeTheseTypes::A,
            payload: union_IncludeTheseTypes {
                A: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn B(payload: Command) -> Self {
        Self {
            discriminant: discriminant_IncludeTheseTypes::B,
            payload: union_IncludeTheseTypes {
                B: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn C(payload: Output) -> Self {
        Self {
            discriminant: discriminant_IncludeTheseTypes::C,
            payload: union_IncludeTheseTypes {
                C: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn D(payload: IOError) -> Self {
        Self {
            discriminant: discriminant_IncludeTheseTypes::D,
            payload: union_IncludeTheseTypes {
                D: payload,
            }
        }
    }

    pub fn E(payload: DirEntry) -> Self {
        Self {
            discriminant: discriminant_IncludeTheseTypes::E,
            payload: union_IncludeTheseTypes {
                E: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn F(payload: ReadErr) -> Self {
        Self {
            discriminant: discriminant_IncludeTheseTypes::F,
            payload: union_IncludeTheseTypes {
                F: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn G(payload: WriteErr) -> Self {
        Self {
            discriminant: discriminant_IncludeTheseTypes::G,
            payload: union_IncludeTheseTypes {
                G: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn H(payload: u32) -> Self {
        Self {
            discriminant: discriminant_IncludeTheseTypes::H,
            payload: union_IncludeTheseTypes {
                H: payload,
            }
        }
    }

    pub fn I(payload: ConnectErr) -> Self {
        Self {
            discriminant: discriminant_IncludeTheseTypes::I,
            payload: union_IncludeTheseTypes {
                I: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn J(payload: StreamErr) -> Self {
        Self {
            discriminant: discriminant_IncludeTheseTypes::J,
            payload: union_IncludeTheseTypes {
                J: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn K(payload: ConnectResult) -> Self {
        Self {
            discriminant: discriminant_IncludeTheseTypes::K,
            payload: union_IncludeTheseTypes {
                K: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn L(payload: WriteResult) -> Self {
        Self {
            discriminant: discriminant_IncludeTheseTypes::L,
            payload: union_IncludeTheseTypes {
                L: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn M(payload: ReadResult) -> Self {
        Self {
            discriminant: discriminant_IncludeTheseTypes::M,
            payload: union_IncludeTheseTypes {
                M: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn N(payload: ReadExactlyResult) -> Self {
        Self {
            discriminant: discriminant_IncludeTheseTypes::N,
            payload: union_IncludeTheseTypes {
                N: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn O(payload: Request) -> Self {
        Self {
            discriminant: discriminant_IncludeTheseTypes::O,
            payload: union_IncludeTheseTypes {
                O: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn P(payload: Method) -> Self {
        Self {
            discriminant: discriminant_IncludeTheseTypes::P,
            payload: union_IncludeTheseTypes {
                P: payload,
            }
        }
    }

    pub fn Q(payload: Header) -> Self {
        Self {
            discriminant: discriminant_IncludeTheseTypes::Q,
            payload: union_IncludeTheseTypes {
                Q: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn R(payload: TimeoutConfig) -> Self {
        Self {
            discriminant: discriminant_IncludeTheseTypes::R,
            payload: union_IncludeTheseTypes {
                R: payload,
            }
        }
    }

    pub fn S(payload: Part) -> Self {
        Self {
            discriminant: discriminant_IncludeTheseTypes::S,
            payload: union_IncludeTheseTypes {
                S: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn T(payload: Body) -> Self {
        Self {
            discriminant: discriminant_IncludeTheseTypes::T,
            payload: union_IncludeTheseTypes {
                T: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn U(payload: Response) -> Self {
        Self {
            discriminant: discriminant_IncludeTheseTypes::U,
            payload: union_IncludeTheseTypes {
                U: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn V(payload: Metadata) -> Self {
        Self {
            discriminant: discriminant_IncludeTheseTypes::V,
            payload: union_IncludeTheseTypes {
                V: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn W(payload: Error) -> Self {
        Self {
            discriminant: discriminant_IncludeTheseTypes::W,
            payload: union_IncludeTheseTypes {
                W: core::mem::ManuallyDrop::new(payload),
            }
        }
    }
}

impl Drop for IncludeTheseTypes {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_IncludeTheseTypes::A => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.A) },
            discriminant_IncludeTheseTypes::B => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.B) },
            discriminant_IncludeTheseTypes::C => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.C) },
            discriminant_IncludeTheseTypes::D => {}
            discriminant_IncludeTheseTypes::E => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.E) },
            discriminant_IncludeTheseTypes::F => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.F) },
            discriminant_IncludeTheseTypes::G => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.G) },
            discriminant_IncludeTheseTypes::H => {}
            discriminant_IncludeTheseTypes::I => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.I) },
            discriminant_IncludeTheseTypes::J => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.J) },
            discriminant_IncludeTheseTypes::K => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.K) },
            discriminant_IncludeTheseTypes::L => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.L) },
            discriminant_IncludeTheseTypes::M => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.M) },
            discriminant_IncludeTheseTypes::N => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.N) },
            discriminant_IncludeTheseTypes::O => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.O) },
            discriminant_IncludeTheseTypes::P => {}
            discriminant_IncludeTheseTypes::Q => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.Q) },
            discriminant_IncludeTheseTypes::R => {}
            discriminant_IncludeTheseTypes::S => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.S) },
            discriminant_IncludeTheseTypes::T => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.T) },
            discriminant_IncludeTheseTypes::U => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.U) },
            discriminant_IncludeTheseTypes::V => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.V) },
            discriminant_IncludeTheseTypes::W => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.W) },
        }
    }
}



pub fn mainForHost() -> IncludeTheseTypes {
    extern "C" {
        fn roc__mainForHost_1_exposed_generic(_: *mut IncludeTheseTypes);
    }

    let mut ret = core::mem::MaybeUninit::uninit();

    unsafe {
        roc__mainForHost_1_exposed_generic(ret.as_mut_ptr(), );

        ret.assume_init()
    }
}